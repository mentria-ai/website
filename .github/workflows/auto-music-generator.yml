name: Auto Music Generator

on:
  schedule:
    # Runs every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:  # Allow manual triggering for testing
    inputs:
      custom_theme:
        description: 'Optional theme for music generation (e.g., "ambient", "electronic", "rock")'
        required: false
        default: ''
      use_seed:
        description: 'Use a specific seed for reproducible generation (0-4294967295, or leave blank for random)'
        required: false
        default: ''

# Explicit permission scoping
permissions:
  contents: read
  issues: write
  actions: read

jobs:
  generate-music-request:
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Should complete quickly
    
    steps:
      - name: Validate API key and setup
        id: validate-setup
        run: |
          echo "🔑 Validating Together API key..."
          if [[ -z "${{ secrets.TOGETHER_API_KEY }}" ]]; then
            echo "::error::Missing Together API key. Please add it to your repository secrets."
            exit 1
          fi
          
          # Create log file
          LOG_FILE="auto_music_generator_$(date +%Y%m%d_%H%M%S).log"
          echo "# Auto Music Generator Log - $(date -u +"%Y-%m-%dT%H:%M:%SZ")" > "$LOG_FILE"
          echo "## Workflow Started" >> "$LOG_FILE"
          echo "- Triggered by: ${{ github.event_name }}" >> "$LOG_FILE"
          echo "- Run ID: ${{ github.run_id }}" >> "$LOG_FILE"
          echo "- Repository: ${{ github.repository }}" >> "$LOG_FILE"
          echo "" >> "$LOG_FILE"
          
          echo "log_file=$LOG_FILE" >> $GITHUB_OUTPUT
          echo "✅ Setup validation completed"
      
      - name: Generate music parameters with AI
        id: generate-params
        run: |
          echo "🎵 Generating music parameters using DeepSeek-V3..."
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## AI Music Parameter Generation" >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Get custom theme and seed if provided
          CUSTOM_THEME="${{ github.event.inputs.custom_theme }}"
          CUSTOM_SEED="${{ github.event.inputs.use_seed }}"
          if [[ -n "$CUSTOM_THEME" ]]; then
            echo "🎨 Using custom theme: $CUSTOM_THEME" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          if [[ -n "$CUSTOM_SEED" ]]; then
            echo "🎲 Using specified seed: $CUSTOM_SEED" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          
          # Create the system prompt with current context
          CURRENT_TIME=$(date +"%H:%M")
          CURRENT_DATE=$(date +"%A, %B %d, %Y")
          
          # Create prompt in smaller chunks to avoid GitHub Actions parsing issues
          echo "You are an AI music production specialist with deep expertise in ACE-Step. Generate creative music parameters optimized for ACE-Step's capabilities." > music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**Current Context:**" >> music_generation_prompt.txt
          echo "- Current time: $CURRENT_TIME" >> music_generation_prompt.txt
          echo "- Current date: $CURRENT_DATE" >> music_generation_prompt.txt
          echo "- Target system: ACE-Step AI music generation" >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**1. Style Prompt:** Create 4-8 comma-separated, lowercase tags covering genre, mood, instruments, production style." >> music_generation_prompt.txt
          echo "Examples: \"electronic, ambient, ethereal, synthesizer\" or \"folk, acoustic, storytelling, guitar\"" >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**2. Lyrics:** Use structured format with [verse], [chorus], [bridge], [outro] markers OR [inst] for instrumental." >> music_generation_prompt.txt
          echo "Create original, genre-appropriate lyrics that flow naturally and tell a coherent story." >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**3. Duration:** Choose from 30, 45, 60, 90, 120, 150, 180, or 240 seconds based on content scope." >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**4. Title:** Generate creative, genre-appropriate, radio-friendly titles." >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**5. Inspiration:** Brief explanation of creative choices and influences." >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**Output Format (JSON only):**" >> music_generation_prompt.txt
          echo '{' >> music_generation_prompt.txt
          echo '  "style_prompt": "comma-separated, lowercase tags",' >> music_generation_prompt.txt
          echo '  "lyrics": "structured lyrics with [section] markers OR [inst]",' >> music_generation_prompt.txt
          echo '  "duration": number (30-240),' >> music_generation_prompt.txt
          echo '  "title_suggestion": "creative title",' >> music_generation_prompt.txt
          echo '  "inspiration": "brief explanation",' >> music_generation_prompt.txt
          echo '  "seed": number (0-4294967295, optional - only if requested)' >> music_generation_prompt.txt
          echo '}' >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "**Quality Standards:** All content must be original, culturally sensitive, and radio-appropriate." >> music_generation_prompt.txt
          echo "**Diversity Goals:** Explore different genres, cultures, and emotional ranges." >> music_generation_prompt.txt
          echo "" >> music_generation_prompt.txt
          echo "Generate something musically compelling and ACE-Step optimized now:" >> music_generation_prompt.txt
          
          # Add custom theme to prompt if provided
          if [[ -n "$CUSTOM_THEME" ]]; then
            echo "" >> music_generation_prompt.txt
            echo "**Special Theme Request:** Focus on or incorporate elements of: $CUSTOM_THEME" >> music_generation_prompt.txt
          fi
          
          # Add seed information if provided
          if [[ -n "$CUSTOM_SEED" ]]; then
            echo "" >> music_generation_prompt.txt
            echo "**Seed Requirement:** The user has specified seed $CUSTOM_SEED for reproducible generation. Include this exact seed value in your response." >> music_generation_prompt.txt
          fi
          
          # Create API request payload using Python to avoid jq parsing issues
          # Build Python script using echo to avoid YAML parsing conflicts
          echo "import json" > create_json.py
          echo "" >> create_json.py
          echo "with open('music_generation_prompt.txt', 'r') as f:" >> create_json.py
          echo "    prompt_content = f.read()" >> create_json.py
          echo "" >> create_json.py
          echo "payload = {" >> create_json.py
          echo "    'model': 'deepseek-ai/DeepSeek-V3'," >> create_json.py
          echo "    'messages': [{'role': 'user', 'content': prompt_content}]," >> create_json.py
          echo "    'max_tokens': 1000," >> create_json.py
          echo "    'temperature': 0.8" >> create_json.py
          echo "}" >> create_json.py
          echo "" >> create_json.py
          echo "with open('api_request.json', 'w') as f:" >> create_json.py
          echo "    json.dump(payload, f)" >> create_json.py
          
          # Execute the Python script
          python3 create_json.py
          
          echo "📡 Making API call to Together AI..." >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Make API call with detailed error handling
          HTTP_STATUS=$(curl -s -w "%{http_code}" -X POST "https://api.together.xyz/v1/chat/completions" \
            -H "Authorization: Bearer ${{ secrets.TOGETHER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d @api_request.json \
            -o api_response.json)
          
          echo "📊 HTTP Status Code: $HTTP_STATUS" >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Check if API call was successful
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✅ API call completed successfully" >> ${{ steps.validate-setup.outputs.log_file }}
            
            # Check if response file exists and has content
            if [[ -f "api_response.json" && -s "api_response.json" ]]; then
              echo "📁 Response file exists and has content" >> ${{ steps.validate-setup.outputs.log_file }}
              
              # Log first 200 characters of response for debugging
              echo "🔍 Response preview: $(head -c 200 api_response.json)" >> ${{ steps.validate-setup.outputs.log_file }}
              
              # Validate JSON format before parsing
              if python3 -c "import json; json.load(open('api_response.json'))" 2>/dev/null; then
                echo "✅ Response is valid JSON" >> ${{ steps.validate-setup.outputs.log_file }}
                
                # Extract content from response using Python for better error handling
                echo "import json" > extract_response.py
                echo "import sys" >> extract_response.py
                echo "" >> extract_response.py
                echo "try:" >> extract_response.py
                echo "    with open('api_response.json', 'r') as f:" >> extract_response.py
                echo "        response = json.load(f)" >> extract_response.py
                echo "" >> extract_response.py
                echo "    # Extract the content" >> extract_response.py
                echo "    content = response.get('choices', [{}])[0].get('message', {}).get('content', '')" >> extract_response.py
                echo "" >> extract_response.py
                echo "    if content:" >> extract_response.py
                echo "        print(f'SUCCESS:{content}')" >> extract_response.py
                echo "    else:" >> extract_response.py
                echo "        print('ERROR:No content found in response')" >> extract_response.py
                echo "" >> extract_response.py
                echo "except Exception as e:" >> extract_response.py
                echo "    print(f'ERROR:Failed to parse response: {e}')" >> extract_response.py
                
                EXTRACTION_RESULT=$(python3 extract_response.py)
                
                if [[ "$EXTRACTION_RESULT" == SUCCESS:* ]]; then
                  RESPONSE_CONTENT="${EXTRACTION_RESULT#SUCCESS:}"
                  echo "🎼 AI Response received (${#RESPONSE_CONTENT} characters)" >> ${{ steps.validate-setup.outputs.log_file }}
                  echo "📝 AI Response preview (first 500 chars):" >> ${{ steps.validate-setup.outputs.log_file }}
                  echo "${RESPONSE_CONTENT:0:500}..." >> ${{ steps.validate-setup.outputs.log_file }}
                  
                  # Extract JSON from response using Python
                  # Create a simple Python script to extract JSON
                  echo "import sys, json, re" > extract_json.py
                  echo "try:" >> extract_json.py
                  echo "    with open('response_content.txt', 'r') as f:" >> extract_json.py
                  echo "        content = f.read()" >> extract_json.py
                  echo "    " >> extract_json.py
                  echo "    # Try to find JSON in markdown code blocks first" >> extract_json.py
                  echo "    code_block = re.search(r'\`\`\`(?:json)?\\s*(\\{.*?\\})\\s*\`\`\`', content, re.DOTALL)" >> extract_json.py
                  echo "    if code_block:" >> extract_json.py
                  echo "        json_text = code_block.group(1)" >> extract_json.py
                  echo "    else:" >> extract_json.py
                  echo "        # Try to find any JSON object with style_prompt" >> extract_json.py
                  echo "        json_match = re.search(r'(\\{[^{}]*\"style_prompt\"[^{}]*\\})', content, re.DOTALL)" >> extract_json.py
                  echo "        if json_match:" >> extract_json.py
                  echo "            json_text = json_match.group(1)" >> extract_json.py
                  echo "        else:" >> extract_json.py
                  echo "            # Find first { and last }" >> extract_json.py
                  echo "            start = content.find('{')" >> extract_json.py
                  echo "            end = content.rfind('}') + 1" >> extract_json.py
                  echo "            if start != -1 and end > start:" >> extract_json.py
                  echo "                json_text = content[start:end]" >> extract_json.py
                  echo "            else:" >> extract_json.py
                  echo "                json_text = None" >> extract_json.py
                  echo "    " >> extract_json.py
                  echo "    if json_text:" >> extract_json.py
                  echo "        try:" >> extract_json.py
                  echo "            data = json.loads(json_text)" >> extract_json.py
                  echo "            with open('extracted_json.txt', 'w') as f:" >> extract_json.py
                  echo "                json.dump(data, f)" >> extract_json.py
                  echo "            print('SUCCESS')" >> extract_json.py
                  echo "            sys.exit(0)" >> extract_json.py
                  echo "        except: pass" >> extract_json.py
                  echo "    " >> extract_json.py
                  echo "    # Fallback" >> extract_json.py
                  echo "    fallback = {'style_prompt': 'electronic, ambient, melodic', 'lyrics': '[inst]', 'duration': 90, 'title_suggestion': 'AI Generated Track', 'inspiration': 'Auto-generated'}" >> extract_json.py
                  echo "    with open('extracted_json.txt', 'w') as f:" >> extract_json.py
                  echo "        json.dump(fallback, f)" >> extract_json.py
                  echo "    print('FALLBACK')" >> extract_json.py
                  echo "except Exception as e:" >> extract_json.py
                  echo "    print('ERROR')" >> extract_json.py
                  
                  # Save response content to file (safer than shell variables)
                  printf '%s' "$RESPONSE_CONTENT" > response_content.txt
                  
                  JSON_EXTRACTION_RESULT=$(python3 extract_json.py)
                  echo "🔍 JSON extraction result: $JSON_EXTRACTION_RESULT" >> ${{ steps.validate-setup.outputs.log_file }}
                  
                  # Debug: Show what was extracted
                  if [[ -f "extracted_json.txt" ]]; then
                    echo "📊 Extracted JSON content:" >> ${{ steps.validate-setup.outputs.log_file }}
                    head -c 200 extracted_json.txt >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "" >> ${{ steps.validate-setup.outputs.log_file }}
                  fi
                  
                  # Validate and extract parameters using Python
                  echo "import json" > extract_params.py
                  echo "import sys" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "try:" >> extract_params.py
                  echo "    with open('extracted_json.txt', 'r') as f:" >> extract_params.py
                  echo "        content = f.read().strip()" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    try:" >> extract_params.py
                  echo "        data = json.loads(content)" >> extract_params.py
                  echo "    except:" >> extract_params.py
                  echo "        # If not valid JSON, create fallback" >> extract_params.py
                  echo "        data = {}" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Extract parameters with fallbacks" >> extract_params.py
                  echo "    style_prompt = data.get('style_prompt', 'electronic, ambient, melodic')" >> extract_params.py
                  echo "    lyrics = data.get('lyrics', '[inst]')" >> extract_params.py
                  echo "    duration = data.get('duration', 90)" >> extract_params.py
                  echo "    title_suggestion = data.get('title_suggestion', 'AI Generated Track')" >> extract_params.py
                  echo "    inspiration = data.get('inspiration', 'Automatically generated music')" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Validate duration" >> extract_params.py
                  echo "    valid_durations = [30, 45, 60, 90, 120, 150, 180, 240]" >> extract_params.py
                  echo "    if duration not in valid_durations:" >> extract_params.py
                  echo "        duration = 90" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Clean parameters" >> extract_params.py
                  echo "    style_prompt = str(style_prompt).replace('\"', '').replace(\"'\", '')[:200]" >> extract_params.py
                  echo "    lyrics = str(lyrics).replace('\"', '').replace(\"'\", '')[:400]" >> extract_params.py
                  echo "    title_suggestion = str(title_suggestion).replace('\"', '').replace(\"'\", '')[:80]" >> extract_params.py
                  echo "    inspiration = str(inspiration).replace('\"', '').replace(\"'\", '')[:200]" >> extract_params.py
                  echo "    seed = data.get('seed', None)" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Validate seed if provided" >> extract_params.py
                  echo "    if seed is not None:" >> extract_params.py
                  echo "        try:" >> extract_params.py
                  echo "            seed = int(seed)" >> extract_params.py
                  echo "            if seed < 0 or seed > 4294967295:" >> extract_params.py
                  echo "                seed = None" >> extract_params.py
                  echo "        except:" >> extract_params.py
                  echo "            seed = None" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    print(f'STYLE_PROMPT={style_prompt}')" >> extract_params.py
                  echo "    print(f'LYRICS={lyrics}')" >> extract_params.py
                  echo "    print(f'DURATION={duration}')" >> extract_params.py
                  echo "    print(f'TITLE_SUGGESTION={title_suggestion}')" >> extract_params.py
                  echo "    print(f'INSPIRATION={inspiration}')" >> extract_params.py
                  echo "    print(f'SEED={seed if seed is not None else \"\"}')" >> extract_params.py
                  echo "    print('SUCCESS=true')" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "except Exception as e:" >> extract_params.py
                  echo "    print(f'ERROR: {e}')" >> extract_params.py
                  echo "    print('SUCCESS=false')" >> extract_params.py
                  
                  # Extract parameters
                  PARAM_RESULT=$(python3 extract_params.py)
                  
                  if echo "$PARAM_RESULT" | grep -q "SUCCESS=true"; then
                    # Extract each parameter
                    STYLE_PROMPT=$(echo "$PARAM_RESULT" | grep "STYLE_PROMPT=" | cut -d'=' -f2-)
                    LYRICS=$(echo "$PARAM_RESULT" | grep "LYRICS=" | cut -d'=' -f2-)
                    DURATION=$(echo "$PARAM_RESULT" | grep "DURATION=" | cut -d'=' -f2-)
                    TITLE_SUGGESTION=$(echo "$PARAM_RESULT" | grep "TITLE_SUGGESTION=" | cut -d'=' -f2-)
                    INSPIRATION=$(echo "$PARAM_RESULT" | grep "INSPIRATION=" | cut -d'=' -f2-)
                    AI_GENERATED_SEED=$(echo "$PARAM_RESULT" | grep "SEED=" | cut -d'=' -f2-)
                    
                    # Use custom seed if provided, otherwise use AI-generated seed
                    FINAL_SEED=""
                    if [[ -n "$CUSTOM_SEED" ]]; then
                      FINAL_SEED="$CUSTOM_SEED"
                      echo "Using provided seed: $FINAL_SEED" >> ${{ steps.validate-setup.outputs.log_file }}
                    elif [[ -n "$AI_GENERATED_SEED" ]]; then
                      FINAL_SEED="$AI_GENERATED_SEED"
                      echo "Using AI-generated seed: $FINAL_SEED" >> ${{ steps.validate-setup.outputs.log_file }}
                    else
                      echo "No seed specified, will use random generation" >> ${{ steps.validate-setup.outputs.log_file }}
                    fi
                    
                    # Encode parameters to prevent JavaScript syntax errors
                    STYLE_PROMPT_ENCODED=$(echo "$STYLE_PROMPT" | base64 -w 0)
                    LYRICS_ENCODED=$(echo "$LYRICS" | base64 -w 0)
                    TITLE_SUGGESTION_ENCODED=$(echo "$TITLE_SUGGESTION" | base64 -w 0)
                    INSPIRATION_ENCODED=$(echo "$INSPIRATION" | base64 -w 0)
                    SEED_ENCODED=$(echo "$FINAL_SEED" | base64 -w 0)
                    
                    echo "🎵 Generated Parameters:" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Style: $STYLE_PROMPT" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Lyrics: ${LYRICS:0:100}..." >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Duration: $DURATION seconds" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Title: $TITLE_SUGGESTION" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Inspiration: $INSPIRATION" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Seed: ${FINAL_SEED:-'random'}" >> ${{ steps.validate-setup.outputs.log_file }}
                    
                    # Set outputs for next step (using encoded versions for JavaScript safety)
                    echo "style_prompt_encoded=$STYLE_PROMPT_ENCODED" >> $GITHUB_OUTPUT
                    echo "lyrics_encoded=$LYRICS_ENCODED" >> $GITHUB_OUTPUT
                    echo "duration=$DURATION" >> $GITHUB_OUTPUT
                    echo "title_suggestion_encoded=$TITLE_SUGGESTION_ENCODED" >> $GITHUB_OUTPUT
                    echo "inspiration_encoded=$INSPIRATION_ENCODED" >> $GITHUB_OUTPUT
                    echo "seed_encoded=$SEED_ENCODED" >> $GITHUB_OUTPUT
                    echo "generation_success=true" >> $GITHUB_OUTPUT
                  else
                    echo "❌ Failed to extract parameters from AI response" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "generation_success=false" >> $GITHUB_OUTPUT
                  fi
                else
                  echo "❌ Failed to extract content from API response" >> ${{ steps.validate-setup.outputs.log_file }}
                  echo "generation_success=false" >> $GITHUB_OUTPUT
                fi
              else
                echo "❌ API response is not valid JSON" >> ${{ steps.validate-setup.outputs.log_file }}
                echo "📄 Raw response content:" >> ${{ steps.validate-setup.outputs.log_file }}
                cat api_response.json >> ${{ steps.validate-setup.outputs.log_file }}
                echo "generation_success=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "❌ API response file is missing or empty" >> ${{ steps.validate-setup.outputs.log_file }}
              echo "generation_success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ API call failed with HTTP status: $HTTP_STATUS" >> ${{ steps.validate-setup.outputs.log_file }}
            if [[ -f "api_response.json" ]]; then
              echo "📄 Error response content:" >> ${{ steps.validate-setup.outputs.log_file }}
              cat api_response.json >> ${{ steps.validate-setup.outputs.log_file }}
            fi
            echo "generation_success=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create music generation issue
        if: steps.generate-params.outputs.generation_success == 'true'
        id: create-issue
        env:
          STYLE_PROMPT_B64: ${{ steps.generate-params.outputs.style_prompt_encoded }}
          LYRICS_B64: ${{ steps.generate-params.outputs.lyrics_encoded }}
          DURATION: ${{ steps.generate-params.outputs.duration }}
          TITLE_B64: ${{ steps.generate-params.outputs.title_suggestion_encoded }}
          INSPIRATION_B64: ${{ steps.generate-params.outputs.inspiration_encoded }}
          SEED_B64: ${{ steps.generate-params.outputs.seed_encoded }}
          CUSTOM_THEME: ${{ github.event.inputs.custom_theme }}
          LOG_FILE: ${{ steps.validate-setup.outputs.log_file }}
        run: |
          # Create JavaScript file to avoid YAML parsing issues
          cat > create_issue.js << 'JSEOF'
          const fs = require('fs');
          const { Octokit } = require('@octokit/rest');
          
          async function createIssue() {
            const logFile = process.env.LOG_FILE;
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            try {
              fs.appendFileSync(logFile, '\n## Creating GitHub Issue\n');
              
              // Decode parameters
              const stylePrompt = process.env.STYLE_PROMPT_B64 ? Buffer.from(process.env.STYLE_PROMPT_B64, 'base64').toString('utf8') : 'electronic, ambient, melodic';
              const lyrics = process.env.LYRICS_B64 ? Buffer.from(process.env.LYRICS_B64, 'base64').toString('utf8') : '[inst]';
              const duration = process.env.DURATION || '90';
              const titleSuggestion = process.env.TITLE_B64 ? Buffer.from(process.env.TITLE_B64, 'base64').toString('utf8') : 'AI Generated Track';
              const inspiration = process.env.INSPIRATION_B64 ? Buffer.from(process.env.INSPIRATION_B64, 'base64').toString('utf8') : 'Auto-generated';
              const seedValue = process.env.SEED_B64 ? Buffer.from(process.env.SEED_B64, 'base64').toString('utf8') : '';
              const customTheme = process.env.CUSTOM_THEME || 'None';
              
              const timestampForTitle = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '');
              const timestampForBody = new Date().toISOString().slice(0, 16).replace('T', ' ');
              const issueTitle = `[MUSIC] ${titleSuggestion} - Auto Generated ${timestampForTitle}`;
              
              // Build seed section
              let seedSection = '';
              if (seedValue && seedValue.trim() !== '') {
                seedSection = `### 🎲 Random Seed (Optional)\n${seedValue}\n\n`;
              }
              
              const issueBody = [
                '## 🎵 Auto-Generated Music Request',
                '',
                'This music generation request was automatically created by the Auto Music Generator workflow.',
                '',
                '### 🎼 Music Style Prompt',
                stylePrompt,
                '',
                '### 🎤 Lyrics or Structure',
                lyrics,
                '',
                '### ⏱️ Duration (seconds)',
                duration,
                '',
                '### 🎚️ Quality Mode',
                'ultra',
                '',
                ...(seedValue && seedValue.trim() !== '' ? [
                  '### 🎲 Random Seed (Optional)',
                  seedValue,
                  ''
                ] : []),
                '### 📝 Additional Notes',
                `**AI Inspiration:** ${inspiration}`,
                '',
                `**Generated at:** ${timestampForBody}`,
                `**Custom theme:** ${customTheme}`,
                ...(seedValue && seedValue.trim() !== '' ? [`**Seed:** ${seedValue} (for reproducible generation)`] : []),
                '',
                '---',
                '',
                '### ✅ Confirmation',
                '- [x] I have the necessary permissions (owner/admin/maintainer) to request audio generation',
                '- [x] I understand that the OctoBeats server must be running for this to work',
                '- [x] I understand that this will create a new branch and pull request with the generated audio',
                '- [x] The parameters I have provided are appropriate and follow community guidelines',
                '',
                '---',
                '',
                '*This issue was automatically generated by the Auto Music Generator workflow. The parameters were created using DeepSeek-V3 AI model to ensure creative diversity and musical interest.*'
              ].join('\n');
              
              const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
              
              const issue = await octokit.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['audio', 'octobeats', 'auto-generated']
              });
              
              fs.appendFileSync(logFile, `✅ Created issue #${issue.data.number}: "${issue.data.title}"\n`);
              fs.appendFileSync(logFile, `🔗 Issue URL: ${issue.data.html_url}\n`);
              
              // Use the newer GitHub Actions output format with proper escaping
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `issue_number=${issue.data.number}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `issue_url=${issue.data.html_url}\n`);
              
              // Escape special characters in issue title for GitHub Actions output
              const escapedTitle = issue.data.title.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/:/g, '%3A');
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `issue_title=${escapedTitle}\n`);
            } catch (error) {
              fs.appendFileSync(logFile, `❌ Error creating GitHub issue: ${error.message}\n`);
              console.log(`::error::Error creating issue: ${error.message}`);
              process.exit(1);
            }
          }
          
          createIssue();
          JSEOF
          
          # Install required packages and run (if not already installed)
          if [ ! -d "node_modules" ]; then
            npm init -y > /dev/null 2>&1
            npm install @octokit/rest > /dev/null 2>&1
          fi
          GITHUB_TOKEN="${{ secrets.PAT || secrets.GITHUB_TOKEN }}" node create_issue.js
      
      - name: Handle generation failure
        if: steps.generate-params.outputs.generation_success != 'true'
        id: handle-generation-failure
        run: |
          echo "❌ Music parameter generation failed" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## Fallback Parameters" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "Using fallback parameters to create a basic music request..." >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Set fallback parameters
          FALLBACK_STYLES=("electronic, ambient, chill" "acoustic, folk, peaceful" "jazz, smooth, relaxing" "classical, orchestral, elegant" "synthwave, retro, nostalgic")
          FALLBACK_DURATIONS=(60 90 120)
          
          # Select random fallback values
          RANDOM_STYLE=${FALLBACK_STYLES[$RANDOM % ${#FALLBACK_STYLES[@]}]}
          RANDOM_DURATION=${FALLBACK_DURATIONS[$RANDOM % ${#FALLBACK_DURATIONS[@]}]}
          FALLBACK_TITLE="Auto Generated Track $(date +%H%M)"
          FALLBACK_INSPIRATION="Generated using fallback parameters after AI generation failed"
          
          # Encode fallback parameters for JavaScript safety
          FALLBACK_STYLE_ENCODED=$(echo "$RANDOM_STYLE" | base64 -w 0)
          FALLBACK_LYRICS_ENCODED=$(echo "[inst]" | base64 -w 0)
          FALLBACK_TITLE_ENCODED=$(echo "$FALLBACK_TITLE" | base64 -w 0)
          FALLBACK_INSPIRATION_ENCODED=$(echo "$FALLBACK_INSPIRATION" | base64 -w 0)
          
          # Handle seed for fallback
          CUSTOM_SEED="${{ github.event.inputs.use_seed }}"
          FALLBACK_SEED_ENCODED=""
          if [[ -n "$CUSTOM_SEED" ]]; then
            FALLBACK_SEED_ENCODED=$(echo "$CUSTOM_SEED" | base64 -w 0)
            echo "Using custom seed for fallback: $CUSTOM_SEED" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          
          echo "fallback_style_encoded=$FALLBACK_STYLE_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_lyrics_encoded=$FALLBACK_LYRICS_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_duration=$RANDOM_DURATION" >> $GITHUB_OUTPUT
          echo "fallback_title_encoded=$FALLBACK_TITLE_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_inspiration_encoded=$FALLBACK_INSPIRATION_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_seed_encoded=$FALLBACK_SEED_ENCODED" >> $GITHUB_OUTPUT
      
      - name: Create fallback issue
        if: steps.generate-params.outputs.generation_success != 'true'
        env:
          FALLBACK_STYLE_B64: ${{ steps.handle-generation-failure.outputs.fallback_style_encoded }}
          FALLBACK_LYRICS_B64: ${{ steps.handle-generation-failure.outputs.fallback_lyrics_encoded }}
          FALLBACK_DURATION: ${{ steps.handle-generation-failure.outputs.fallback_duration }}
          FALLBACK_TITLE_B64: ${{ steps.handle-generation-failure.outputs.fallback_title_encoded }}
          FALLBACK_INSPIRATION_B64: ${{ steps.handle-generation-failure.outputs.fallback_inspiration_encoded }}
          FALLBACK_SEED_B64: ${{ steps.handle-generation-failure.outputs.fallback_seed_encoded }}
          LOG_FILE: ${{ steps.validate-setup.outputs.log_file }}
        run: |
          # Create JavaScript file for fallback issue
          cat > create_fallback_issue.js << 'JSEOF'
          const fs = require('fs');
          const { Octokit } = require('@octokit/rest');
          
          async function createFallbackIssue() {
            const logFile = process.env.LOG_FILE;
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            try {
              fs.appendFileSync(logFile, '\n## Creating Fallback Issue\n');
              
              // Decode fallback parameters
              const fallbackStyle = process.env.FALLBACK_STYLE_B64 ? Buffer.from(process.env.FALLBACK_STYLE_B64, 'base64').toString('utf8') : 'electronic, ambient, melodic';
              const fallbackLyrics = process.env.FALLBACK_LYRICS_B64 ? Buffer.from(process.env.FALLBACK_LYRICS_B64, 'base64').toString('utf8') : '[inst]';
              const fallbackDuration = process.env.FALLBACK_DURATION || '90';
              const fallbackTitle = process.env.FALLBACK_TITLE_B64 ? Buffer.from(process.env.FALLBACK_TITLE_B64, 'base64').toString('utf8') : 'AI Generated Track';
              const fallbackInspiration = process.env.FALLBACK_INSPIRATION_B64 ? Buffer.from(process.env.FALLBACK_INSPIRATION_B64, 'base64').toString('utf8') : 'Fallback parameters';
              const fallbackSeed = process.env.FALLBACK_SEED_B64 ? Buffer.from(process.env.FALLBACK_SEED_B64, 'base64').toString('utf8') : '';
              
              const timestampForTitle = new Date().toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '');
              const timestampForBody = new Date().toISOString().slice(0, 16).replace('T', ' ');
              const issueTitle = `[MUSIC] ${fallbackTitle} - Auto Generated ${timestampForTitle}`;
              
              const issueBody = [
                '## 🎵 Auto-Generated Music Request (Fallback)',
                '',
                'This music generation request was automatically created using fallback parameters due to AI generation failure.',
                '',
                '### 🎼 Music Style Prompt',
                fallbackStyle,
                '',
                '### 🎤 Lyrics or Structure',
                fallbackLyrics,
                '',
                '### ⏱️ Duration (seconds)',
                fallbackDuration,
                '',
                '### 🎚️ Quality Mode',
                'ultra',
                '',
                ...(fallbackSeed && fallbackSeed.trim() !== '' ? [
                  '### 🎲 Random Seed (Optional)',
                  fallbackSeed,
                  ''
                ] : []),
                '### 📝 Additional Notes',
                `**AI Inspiration:** ${fallbackInspiration}`,
                '',
                `**Generated at:** ${timestampForBody}`,
                ...(fallbackSeed && fallbackSeed.trim() !== '' ? [`**Seed:** ${fallbackSeed} (for reproducible generation)`] : []),
                '',
                '---',
                '',
                '### ✅ Confirmation',
                '- [x] I have the necessary permissions (owner/admin/maintainer) to request audio generation',
                '- [x] I understand that the OctoBeats server must be running for this to work',
                '- [x] I understand that this will create a new branch and pull request with the generated audio',
                '- [x] The parameters I have provided are appropriate and follow community guidelines',
                '',
                '---',
                '',
                '*This issue was automatically generated using fallback parameters after AI generation failed.*'
              ].join('\n');
              
              const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
              
              const issue = await octokit.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['audio', 'octobeats', 'auto-generated', 'fallback']
              });
              
              fs.appendFileSync(logFile, `✅ Created fallback issue #${issue.data.number}\n`);
              fs.appendFileSync(logFile, `🔗 Issue URL: ${issue.data.html_url}\n`);
              
              // Set outputs for fallback issue (with proper escaping)
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `fallback_issue_number=${issue.data.number}\n`);
              fs.appendFileSync(process.env.GITHUB_OUTPUT, `fallback_issue_url=${issue.data.html_url}\n`);
              
            } catch (error) {
              fs.appendFileSync(logFile, `❌ Error creating fallback issue: ${error.message}\n`);
              console.log(`::error::Error creating fallback issue: ${error.message}`);
            }
          }
          
          createFallbackIssue();
          JSEOF
          
          # Install required packages and run (if not already installed)
          if [ ! -d "node_modules" ]; then
            npm init -y > /dev/null 2>&1
            npm install @octokit/rest > /dev/null 2>&1
          fi
          GITHUB_TOKEN="${{ secrets.PAT || secrets.GITHUB_TOKEN }}" node create_fallback_issue.js
      
      - name: Cleanup and finalize
        if: always()
        run: |
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## Workflow Completion" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "- Completed at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "- Status: ${{ job.status }}" >> ${{ steps.validate-setup.outputs.log_file }}
          
          if [[ "${{ steps.create-issue.outputs.issue_number }}" != "" ]]; then
            echo "- Created issue: #${{ steps.create-issue.outputs.issue_number }}" >> ${{ steps.validate-setup.outputs.log_file }}
            echo "🎵 Successfully created auto-generated music request!"
          else
            echo "- No issue created (workflow failed or used fallback)" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          
          # Clean up temporary files
          rm -f music_generation_prompt.txt api_request.json api_response.json extracted_json.txt create_json.py extract_response.py extract_json.py extract_params.py response_content.txt create_issue.js create_fallback_issue.js package.json package-lock.json
          rm -rf node_modules
          
          echo "✅ Auto Music Generator workflow completed"
      
      - name: Upload workflow logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: auto-music-generator-logs-${{ github.run_number }}
          path: |
            ${{ steps.validate-setup.outputs.log_file }}
            *.json
            *.txt
          retention-days: 7
