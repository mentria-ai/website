name: OctoBeats Music Generator

on:
  issues:
    types: [opened, edited, labeled]
  issue_comment:
    types: [created, edited]
  # Allow workflow to run when reactions are added (for approval mechanism)
  # Note: GitHub doesn't have a direct reaction trigger, but we can use issue events
  # and check for reactions in the validation step

# CONCURRENCY CONTROL: Prevent multiple workflows for the same issue
# This ensures only one workflow runs per issue, preventing duplicates when
# the issue template automatically adds labels that trigger multiple events
concurrency:
  group: octobeats-issue-${{ github.event.issue.number }}
  cancel-in-progress: true

# Explicit permission scoping for security
permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read

jobs:
  generate-audio:
    runs-on: self-hosted
    timeout-minutes: 120
    
    steps:
      - name: Validate trigger conditions
        id: validate-trigger
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Create log file for this workflow
            const logFile = `octobeats_workflow_${Date.now()}.log`;
            fs.writeFileSync(logFile, 
              `# OctoBeats Music Generator Log - ${new Date().toISOString()}\n` +
              `## Event: ${context.eventName}\n` +
              `## Action: ${context.payload.action}\n` +
              `## Actor: ${context.actor}\n` +
              `## Repository: ${context.repo.owner}/${context.repo.repo}\n` +
              `## Concurrency Group: octobeats-issue-${context.payload.issue?.number}\n\n`
            );
            
            core.setOutput('log_file', logFile);
            
            // Check if this is an audio generation request
            const issue = context.payload.issue;
            if (!issue) {
              fs.appendFileSync(logFile, `âŒ No issue found in payload\n`);
              core.setOutput('should_process', 'false');
              core.setOutput('reason', 'No issue in payload');
              return;
            }
            
            // Log concurrency information
            fs.appendFileSync(logFile, `ðŸ”’ Concurrency group: octobeats-issue-${issue.number}\n`);
            fs.appendFileSync(logFile, `ðŸ“‹ This ensures only one workflow runs per issue\n\n`);
            
            // Check for required labels
            const labels = issue.labels.map(label => label.name.toLowerCase());
            const hasAudioLabel = labels.includes('audio') || labels.includes('octobeats') || labels.includes('music-generation');
            
            fs.appendFileSync(logFile, `Issue #${issue.number}: "${issue.title}"\n`);
            fs.appendFileSync(logFile, `Labels: ${labels.join(', ')}\n`);
            fs.appendFileSync(logFile, `Has audio label: ${hasAudioLabel}\n`);
            
            if (!hasAudioLabel) {
              fs.appendFileSync(logFile, `âŒ Issue does not have required audio generation labels\n`);
              core.setOutput('should_process', 'false');
              core.setOutput('reason', 'Missing required labels (audio, octobeats, or music-generation)');
              return;
            }
            
            // Check if user has permission (owner, admin, maintainer)
            const issueAuthor = issue.user.login;
            fs.appendFileSync(logFile, `Issue author: ${issueAuthor}\n`);
            
            // Get repository information to check permissions
            const { data: repo } = await github.rest.repos.get({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const repoOwner = repo.owner.login;
            fs.appendFileSync(logFile, `Repository owner: ${repoOwner}\n`);
            
            // Check if user is the repository owner
            if (issueAuthor === repoOwner) {
              fs.appendFileSync(logFile, `âœ… User is repository owner\n`);
              core.setOutput('should_process', 'true');
              core.setOutput('user_permission', 'owner');
              return;
            }
            
            // Check if user is a collaborator with admin or maintain permissions
            try {
              const { data: permission } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: issueAuthor
              });
              
              fs.appendFileSync(logFile, `User permission level: ${permission.permission}\n`);
              
              if (['admin', 'maintain'].includes(permission.permission)) {
                fs.appendFileSync(logFile, `âœ… User has sufficient permissions\n`);
                core.setOutput('should_process', 'true');
                core.setOutput('user_permission', permission.permission);
                return;
              } else {
                fs.appendFileSync(logFile, `âŒ User does not have sufficient permissions (${permission.permission})\n`);
                
                // Check for approval reactions from qualified users
                fs.appendFileSync(logFile, `ðŸ” Checking for approval reactions from qualified users...\n`);
                
                try {
                  // Get all reactions on the issue
                  const { data: reactions } = await github.rest.reactions.listForIssue({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number
                  });
                  
                  // Approval reactions we're looking for
                  const approvalReactions = ['+1', 'hooray', 'heart', 'rocket']; // GitHub API names for ðŸ‘, ðŸŽ‰, â¤ï¸, ðŸš€
                  
                  fs.appendFileSync(logFile, `Found ${reactions.length} total reactions\n`);
                  
                  // Check each reaction
                  let approvedByQualifiedUser = false;
                  
                  for (const reaction of reactions) {
                    if (approvalReactions.includes(reaction.content)) {
                      const reactionUser = reaction.user.login;
                      fs.appendFileSync(logFile, `Found approval reaction (${reaction.content}) from: ${reactionUser}\n`);
                      
                      // Check if this user is the repository owner
                      if (reactionUser === repoOwner) {
                        fs.appendFileSync(logFile, `âœ… Approval reaction from repository owner: ${reactionUser}\n`);
                        approvedByQualifiedUser = true;
                        core.setOutput('approved_by', reactionUser);
                        core.setOutput('approval_method', 'owner_reaction');
                        break;
                      }
                      
                      // Check if this user has admin/maintain permissions
                      try {
                        const { data: reactorPermission } = await github.rest.repos.getCollaboratorPermissionLevel({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          username: reactionUser
                        });
                        
                        if (['admin', 'maintain'].includes(reactorPermission.permission)) {
                          fs.appendFileSync(logFile, `âœ… Approval reaction from qualified user: ${reactionUser} (${reactorPermission.permission})\n`);
                          approvedByQualifiedUser = true;
                          core.setOutput('approved_by', reactionUser);
                          core.setOutput('approval_method', `${reactorPermission.permission}_reaction`);
                          break;
                        } else {
                          fs.appendFileSync(logFile, `âŒ Reaction from unqualified user: ${reactionUser} (${reactorPermission.permission})\n`);
                        }
                      } catch (permError) {
                        fs.appendFileSync(logFile, `âš ï¸ Error checking permissions for ${reactionUser}: ${permError.message}\n`);
                      }
                    }
                  }
                  
                  if (approvedByQualifiedUser) {
                    fs.appendFileSync(logFile, `âœ… Issue approved by qualified user via reaction\n`);
                    core.setOutput('should_process', 'true');
                    core.setOutput('user_permission', 'approved_via_reaction');
                    return;
                  } else {
                    fs.appendFileSync(logFile, `âŒ No approval reactions found from qualified users\n`);
                    fs.appendFileSync(logFile, `ðŸ’¡ Hint: Repository owners/admins/maintainers can approve this request by reacting with ðŸ‘, ðŸŽ‰, â¤ï¸, or ðŸš€\n`);
                core.setOutput('should_process', 'false');
                    core.setOutput('reason', `Insufficient permissions. User has '${permission.permission}' but needs 'admin' or 'maintain', or approval from a qualified user via reaction (ðŸ‘, ðŸŽ‰, â¤ï¸, ðŸš€)`);
                return;
                  }
                } catch (reactionError) {
                  fs.appendFileSync(logFile, `âŒ Error checking reactions: ${reactionError.message}\n`);
                  core.setOutput('should_process', 'false');
                  core.setOutput('reason', `Error checking approval reactions: ${reactionError.message}`);
                  return;
                }
              }
            } catch (error) {
              fs.appendFileSync(logFile, `âŒ Error checking user permissions: ${error.message}\n`);
              core.setOutput('should_process', 'false');
              core.setOutput('reason', `Error checking permissions: ${error.message}`);
              return;
            }
      
      - name: Skip workflow if conditions not met
        if: steps.validate-trigger.outputs.should_process != 'true'
        run: |
          echo "â­ï¸ Skipping workflow: ${{ steps.validate-trigger.outputs.reason }}"
          echo ""
          echo "ðŸ“‹ Requirements for OctoBeats Music Generation:"
          echo "   1. Issue must have labels: 'audio', 'octobeats', or 'music-generation'"
          echo "   2. Either:"
          echo "      a) Created by repository owner/admin/maintainer, OR"
          echo "      b) Approved by owner/admin/maintainer via reaction (ðŸ‘, ðŸŽ‰, â¤ï¸, ðŸš€)"
          echo ""
          echo "ðŸ’¡ If you're not an owner/admin/maintainer:"
          echo "   â€¢ Create your issue with the required labels"
          echo "   â€¢ Ask an owner/admin/maintainer to approve it by reacting with ðŸ‘, ðŸŽ‰, â¤ï¸, or ðŸš€"
          echo "   â€¢ The workflow will automatically run once approved"
          exit 0
      
      - name: Check for existing audio generation
        if: steps.validate-trigger.outputs.should_process == 'true'
        id: check-existing
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const logFile = '${{ steps.validate-trigger.outputs.log_file }}';
            
            fs.appendFileSync(logFile, `\n## Checking for Existing Audio Generation\n`);
            
            const issueNumber = context.payload.issue.number;
            
            try {
              // Check if there's already a branch for this issue
              const branchName = `audio-generation/track-${issueNumber}`;
              
              try {
                const { data: branch } = await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branchName
                });
                
                fs.appendFileSync(logFile, `âš ï¸ Found existing branch: ${branchName}\n`);
                
                // Check if there's an open PR for this branch
                const { data: prs } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  head: `${context.repo.owner}:${branchName}`,
                  state: 'open'
                });
                
                if (prs.length > 0) {
                  const pr = prs[0];
                  fs.appendFileSync(logFile, `âœ… Found existing PR #${pr.number}: ${pr.title}\n`);
                  fs.appendFileSync(logFile, `ðŸ”— PR URL: ${pr.html_url}\n`);
                  
                  // Comment on the issue about the existing PR
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issueNumber,
                    body: `## ðŸŽµ Audio Already Generated!
            
            Audio has already been generated for this issue. You can find it in:
            
            **ðŸ“ Pull Request**: [#${pr.number} - ${pr.title}](${pr.html_url})
            
            If you need to regenerate the audio with different parameters:
            1. Close the existing PR
            2. Delete the branch \`${branchName}\`
            3. Edit this issue to trigger a new generation
            
            ---
            *This check prevents duplicate audio generation for the same issue.*`
                  });
                  
                  core.setOutput('should_continue', 'false');
                  core.setOutput('reason', `Audio already generated - PR #${pr.number} exists`);
                  return;
                }
                
                fs.appendFileSync(logFile, `â„¹ï¸ Branch exists but no open PR found, proceeding with generation\n`);
              } catch (error) {
                if (error.status === 404) {
                  fs.appendFileSync(logFile, `âœ… No existing branch found, proceeding with generation\n`);
                } else {
                  fs.appendFileSync(logFile, `âš ï¸ Error checking branch: ${error.message}\n`);
                }
              }
              
              core.setOutput('should_continue', 'true');
              core.setOutput('reason', 'No existing audio generation found');
              
            } catch (error) {
              fs.appendFileSync(logFile, `âŒ Error checking existing generation: ${error.message}\n`);
              core.setOutput('should_continue', 'true');
              core.setOutput('reason', 'Error checking existing generation, proceeding anyway');
            }
      
      - name: Skip if audio already exists
        if: steps.check-existing.outputs.should_continue != 'true'
        run: |
          echo "â­ï¸ Skipping workflow: ${{ steps.check-existing.outputs.reason }}"
          echo "Audio has already been generated for this issue."
          exit 0
      
      - name: Checkout repository
        if: steps.validate-trigger.outputs.should_process == 'true' && steps.check-existing.outputs.should_continue == 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract audio parameters
        if: steps.validate-trigger.outputs.should_process == 'true' && steps.check-existing.outputs.should_continue == 'true'
        id: extract-params
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const logFile = '${{ steps.validate-trigger.outputs.log_file }}';
            
            fs.appendFileSync(logFile, `\n## Extracting Audio Parameters\n`);
            
            const issue = context.payload.issue;
            const issueBody = issue.body || '';
            
            fs.appendFileSync(logFile, `Issue body length: ${issueBody.length} characters\n`);
            
            // Default parameters
            let audioParams = {
              prompt: 'electronic, melodic',
              lyrics: '[inst]',
              duration: 60,
              mode: 'quality',
              seed: null
            };
            
            // Log the issue body for debugging
            fs.appendFileSync(logFile, `Issue body content:\n${issueBody}\n\n`);
            
            // Extract parameters using GitHub issue form format
            const extractGitHubFormParameter = (fieldName, patterns, defaultValue) => {
              // Try GitHub issue form format first (most reliable)
              for (const pattern of patterns) {
              const match = issueBody.match(pattern);
                if (match && match[1] && match[1].trim()) {
                  const value = match[1].trim();
                  fs.appendFileSync(logFile, `Found ${fieldName}: "${value}"\n`);
                  return value;
                }
              }
              fs.appendFileSync(logFile, `No match found for ${fieldName}, using default: "${defaultValue}"\n`);
              return defaultValue;
            };
            
            // GitHub issue form patterns (these match the template structure)
            const promptPatterns = [
              // GitHub form field format - exact match for our template
              /### ðŸŽ¼ Music Style Prompt\s*\n\s*([^\n]+)/i,
              // Alternative form formats
              /ðŸŽ¼ Music Style Prompt[:\s]*\n\s*([^\n]+)/i,
              // Fallback patterns
              /(?:prompt|style|music[_\s]?style)[:\s]*([^\n\r]+)/i,
              /[-*]\s*(?:prompt|style|music[_\s]?style)[:\s]*([^\n\r]+)/i
            ];
            
            const lyricsPatterns = [
              // GitHub form field format - exact match for our template
              /### ðŸŽ¤ Lyrics or Structure\s*\n\s*([\s\S]*?)(?=\n### |\n\n### |$)/i,
              // Alternative form formats
              /ðŸŽ¤ Lyrics or Structure[:\s]*\n\s*([\s\S]*?)(?=\n### |\n\n### |$)/i,
              // Fallback patterns
              /(?:lyrics|text|words|structure)[:\s]*([^\n\r]+)/i,
              /[-*]\s*(?:lyrics|text|words|structure)[:\s]*([^\n\r]+)/i
            ];
            
            const durationPatterns = [
              // GitHub form field format - exact match for our template
              /### â±ï¸ Duration \(seconds\)\s*\n\s*(\d+)/i,
              // Alternative form formats
              /â±ï¸ Duration[:\s]*\n\s*(\d+)/i,
              // Fallback patterns
              /(?:duration|length|time)[:\s]*(\d+)/i,
              /[-*]\s*(?:duration|length|time)[:\s]*(\d+)/i
            ];
            
            const modePatterns = [
              // GitHub form field format - exact match for our template
              /### ðŸŽšï¸ Quality Mode\s*\n\s*(fast|quality|ultra)/i,
              // Alternative form formats
              /ðŸŽšï¸ Quality Mode[:\s]*\n\s*(fast|quality|ultra)/i,
              // Fallback patterns
              /(?:mode|quality)[:\s]*(fast|quality|ultra)/i,
              /[-*]\s*(?:mode|quality)[:\s]*(fast|quality|ultra)/i
            ];
            
            const seedPatterns = [
              // GitHub form field format - exact match for our template
              /### ðŸŽ² Random Seed \(Optional\)\s*\n\s*(\d+)/i,
              // Alternative form formats
              /ðŸŽ² Random Seed[:\s]*\n\s*(\d+)/i,
              // Fallback patterns
              /(?:seed|random[_\s]?seed)[:\s]*(\d+)/i,
              /[-*]\s*(?:seed|random[_\s]?seed)[:\s]*(\d+)/i
            ];
            
            // Extract parameters using the improved logic
            audioParams.prompt = extractGitHubFormParameter('prompt', promptPatterns, audioParams.prompt);
            audioParams.lyrics = extractGitHubFormParameter('lyrics', lyricsPatterns, audioParams.lyrics);
            
            const durationStr = extractGitHubFormParameter('duration', durationPatterns, audioParams.duration.toString());
            audioParams.duration = parseInt(durationStr) || audioParams.duration;
            
            audioParams.mode = extractGitHubFormParameter('mode', modePatterns, audioParams.mode);
            
            const seedStr = extractGitHubFormParameter('seed', seedPatterns, '');
            if (seedStr && seedStr.trim() !== '') {
              const seedValue = parseInt(seedStr);
              if (seedValue >= 0 && seedValue <= 4294967295) {
                audioParams.seed = seedValue;
                fs.appendFileSync(logFile, `Seed specified: ${seedValue}\n`);
              } else {
                fs.appendFileSync(logFile, `âš ï¸ Seed ${seedValue} out of range (0-4294967295), using random\n`);
                audioParams.seed = null;
              }
            } else {
              fs.appendFileSync(logFile, `No seed specified, using random generation\n`);
              audioParams.seed = null;
            }
            
            // Validate and sanitize parameters
            if (audioParams.duration) {
              const duration = parseInt(audioParams.duration);
              if (duration < 30 || duration > 240) {
                fs.appendFileSync(logFile, `âš ï¸ Duration ${duration} out of range, using default 60\n`);
                audioParams.duration = 60;
              } else {
                audioParams.duration = duration;
              }
            }
            
            if (!['fast', 'quality', 'ultra'].includes(audioParams.mode)) {
              fs.appendFileSync(logFile, `âš ï¸ Invalid mode '${audioParams.mode}', using default 'quality'\n`);
              audioParams.mode = 'quality';
            }
            
            // Clean up prompt and lyrics
            audioParams.prompt = audioParams.prompt.replace(/[`"']/g, '').trim();
            audioParams.lyrics = audioParams.lyrics
              .replace(/[`"']/g, '')  // Remove quotes
              .replace(/^\s*\n+/, '')  // Remove leading newlines
              .replace(/\n+\s*$/, '')  // Remove trailing newlines
              .trim();
            
            // If lyrics is empty or just whitespace, use default
            if (!audioParams.lyrics || audioParams.lyrics.length === 0) {
              audioParams.lyrics = '[inst]';
              fs.appendFileSync(logFile, `Lyrics was empty, using default: [inst]\n`);
            }
            
            fs.appendFileSync(logFile, `\nFinal parameters:\n`);
            fs.appendFileSync(logFile, `- Prompt: "${audioParams.prompt}"\n`);
            fs.appendFileSync(logFile, `- Lyrics: "${audioParams.lyrics}"\n`);
            fs.appendFileSync(logFile, `- Duration: ${audioParams.duration} seconds\n`);
            fs.appendFileSync(logFile, `- Mode: ${audioParams.mode}\n`);
            fs.appendFileSync(logFile, `- Seed: ${audioParams.seed || 'random'}\n`);
            
            // Save parameters to file for next steps
            fs.writeFileSync('audio_params.json', JSON.stringify(audioParams, null, 2));
            
            // Set outputs
            core.setOutput('prompt', audioParams.prompt);
            core.setOutput('lyrics', audioParams.lyrics);
            core.setOutput('duration', audioParams.duration.toString());
            core.setOutput('mode', audioParams.mode);
            core.setOutput('seed', audioParams.seed ? audioParams.seed.toString() : '');
            
            return audioParams;
      
      - name: Check OctoBeats server status
        if: steps.validate-trigger.outputs.should_process == 'true' && steps.check-existing.outputs.should_continue == 'true'
        id: check-server
        run: |
          echo "ðŸ” Checking OctoBeats server status..."
          echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "## OctoBeats Server Status Check" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Try multiple server addresses
          SERVER_URLS=("http://localhost:8000" "http://127.0.0.1:8000" "http://host.docker.internal:8000" "http://172.17.0.1:8000")
          SERVER_FOUND=false
          
          for url in "${SERVER_URLS[@]}"; do
            echo "Trying server at: $url" >> ${{ steps.validate-trigger.outputs.log_file }}
            if curl -f -s --connect-timeout 5 "$url/api/status" > server_status.json 2>/dev/null; then
              echo "âœ… OctoBeats server found at: $url" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "OCTOBEATS_URL=$url" >> $GITHUB_ENV
              SERVER_FOUND=true
              break
            else
              echo "âŒ Server not accessible at: $url" >> ${{ steps.validate-trigger.outputs.log_file }}
            fi
          done
          
          if [ "$SERVER_FOUND" = true ]; then
            echo "âœ… OctoBeats server is running at: $OCTOBEATS_URL" >> ${{ steps.validate-trigger.outputs.log_file }}
            
            # Parse server status
            SERVER_STATUS=$(cat server_status.json | jq -r '.status')
            IS_GENERATING=$(cat server_status.json | jq -r '.generation.is_generating')
            
            echo "Server status: $SERVER_STATUS" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "Currently generating: $IS_GENERATING" >> ${{ steps.validate-trigger.outputs.log_file }}
            
            if [ "$SERVER_STATUS" != "ready" ]; then
              echo "âŒ Server is not ready (status: $SERVER_STATUS)" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "server_ready=false" >> $GITHUB_OUTPUT
              echo "error=Server not ready" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            if [ "$IS_GENERATING" = "true" ]; then
              echo "âš ï¸ Server is currently generating audio" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "server_ready=false" >> $GITHUB_OUTPUT
              echo "error=Server busy generating audio" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            echo "server_ready=true" >> $GITHUB_OUTPUT
            echo "âœ… Server is ready for audio generation" >> ${{ steps.validate-trigger.outputs.log_file }}
          else
            echo "âŒ OctoBeats server is not accessible at any of the tried URLs" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "Tried URLs: ${SERVER_URLS[*]}" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "ðŸ” Running network diagnostic..." >> ${{ steps.validate-trigger.outputs.log_file }}
            
            # Run network diagnostic
            if [ -f ".github/scripts/diagnose-network.sh" ]; then
              chmod +x .github/scripts/diagnose-network.sh
              ./.github/scripts/diagnose-network.sh >> ${{ steps.validate-trigger.outputs.log_file }} 2>&1
            else
              echo "Network diagnostic script not found" >> ${{ steps.validate-trigger.outputs.log_file }}
            fi
            
            echo "server_ready=false" >> $GITHUB_OUTPUT
            echo "error=Server not accessible at any URL" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Generate audio with ACE-Step
        if: steps.validate-trigger.outputs.should_process == 'true' && steps.check-existing.outputs.should_continue == 'true' && steps.check-server.outputs.server_ready == 'true'
        id: generate-audio
        timeout-minutes: 90
        run: |
          echo "ðŸŽµ Generating audio with OctoBeats..."
          echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "## Audio Generation" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Load parameters
          PROMPT="${{ steps.extract-params.outputs.prompt }}"
          LYRICS="${{ steps.extract-params.outputs.lyrics }}"
          DURATION="${{ steps.extract-params.outputs.duration }}"
          MODE="${{ steps.extract-params.outputs.mode }}"
          
          echo "Generating with parameters:" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "- Prompt: $PROMPT" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "- Lyrics: $LYRICS" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "- Duration: $DURATION seconds" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "- Mode: $MODE" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Create request payload using jq for proper JSON formatting
          # Save multiline lyrics to a temporary file to handle newlines properly
          echo "$LYRICS" > temp_lyrics_request.txt
          
          SEED="${{ steps.extract-params.outputs.seed }}"
          
          if [ -n "$SEED" ] && [ "$SEED" != "" ]; then
            echo "Including seed in request: $SEED" >> ${{ steps.validate-trigger.outputs.log_file }}
            jq -n \
              --arg prompt "$PROMPT" \
              --rawfile lyrics temp_lyrics_request.txt \
              --arg duration "$DURATION" \
              --arg mode "$MODE" \
              --arg seed "$SEED" \
              '{
                "prompt": $prompt,
                "lyrics": $lyrics,
                "duration": ($duration | tonumber),
                "mode": $mode,
                "seed": ($seed | tonumber)
              }' > generation_request.json
          else
            echo "No seed specified, using random generation" >> ${{ steps.validate-trigger.outputs.log_file }}
            jq -n \
              --arg prompt "$PROMPT" \
              --rawfile lyrics temp_lyrics_request.txt \
              --arg duration "$DURATION" \
              --arg mode "$MODE" \
              '{
                "prompt": $prompt,
                "lyrics": $lyrics,
                "duration": ($duration | tonumber),
                "mode": $mode
              }' > generation_request.json
          fi
          
          # Clean up temporary file
          rm -f temp_lyrics_request.txt
          
          echo "Request payload:" >> ${{ steps.validate-trigger.outputs.log_file }}
          cat generation_request.json >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Make API call with timeout
          echo "Making API call to OctoBeats at: $OCTOBEATS_URL..." >> ${{ steps.validate-trigger.outputs.log_file }}
          
          if curl -s -X POST "$OCTOBEATS_URL/api/generate" \
            -H "Content-Type: application/json" \
            -d @generation_request.json \
            -o generation_response.json \
            ; then
            
            echo "âœ… API call completed" >> ${{ steps.validate-trigger.outputs.log_file }}
            
            # Check if generation was successful
            SUCCESS=$(cat generation_response.json | jq -r '.success // false')
            
            if [ "$SUCCESS" = "true" ]; then
              FILENAME=$(cat generation_response.json | jq -r '.filename')
              GENERATION_TIME=$(cat generation_response.json | jq -r '.generation_time')
              USED_SEED=$(cat generation_response.json | jq -r '.parameters.seed // ""')
              
              echo "âœ… Audio generated successfully!" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "- Filename: $FILENAME" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "- Generation time: ${GENERATION_TIME}s" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "- Seed used: ${USED_SEED:-'random'}" >> ${{ steps.validate-trigger.outputs.log_file }}
              
              echo "filename=$FILENAME" >> $GITHUB_OUTPUT
              echo "generation_time=$GENERATION_TIME" >> $GITHUB_OUTPUT
              echo "used_seed=${USED_SEED:-''}" >> $GITHUB_OUTPUT
              echo "success=true" >> $GITHUB_OUTPUT
            else
              ERROR_MSG=$(cat generation_response.json | jq -r '.error // "Unknown error"')
              echo "âŒ Audio generation failed: $ERROR_MSG" >> ${{ steps.validate-trigger.outputs.log_file }}
              echo "success=false" >> $GITHUB_OUTPUT
              echo "error=$ERROR_MSG" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ API call failed or timed out" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "success=false" >> $GITHUB_OUTPUT
            echo "error=API call failed or timed out" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Download generated audio
        if: steps.generate-audio.outputs.success == 'true'
        id: download-audio
        run: |
          echo "ðŸ“¥ Downloading generated audio..."
          echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "## Audio Download" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          FILENAME="${{ steps.generate-audio.outputs.filename }}"
          
          # Create audio directory if it doesn't exist
          mkdir -p generated_audio
          
          # Download the audio file
          if curl -X GET "$OCTOBEATS_URL/api/download/$FILENAME" \
            -o "generated_audio/$FILENAME" \
            --max-time 60; then
            
            echo "âœ… Audio downloaded successfully" >> ${{ steps.validate-trigger.outputs.log_file }}
            
            # Check file size
            FILE_SIZE=$(du -h "generated_audio/$FILENAME" | cut -f1)
            echo "- File size: $FILE_SIZE" >> ${{ steps.validate-trigger.outputs.log_file }}
            
            # Create a more descriptive filename
            ISSUE_NUMBER="${{ github.event.issue.number }}"
            TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
            NEW_FILENAME="audio_${ISSUE_NUMBER}_${TIMESTAMP}.mp3"
            
            mv "generated_audio/$FILENAME" "generated_audio/$NEW_FILENAME"
            
            echo "- Renamed to: $NEW_FILENAME" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "local_filename=$NEW_FILENAME" >> $GITHUB_OUTPUT
            echo "file_size=$FILE_SIZE" >> $GITHUB_OUTPUT
            echo "download_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to download audio file" >> ${{ steps.validate-trigger.outputs.log_file }}
            echo "download_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Create branch and commit audio
        if: steps.download-audio.outputs.download_success == 'true'
        id: create-branch
        run: |
          echo "ðŸŒ¿ Creating branch and committing audio..."
          echo "" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "## Branch Creation and Commit" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Configure git
          git config user.name "OctoBeats Music Generator"
          git config user.email "action@github.com"
          
          # Create branch name
          ISSUE_NUMBER="${{ github.event.issue.number }}"
          BRANCH_NAME="audio-generation/track-${ISSUE_NUMBER}"
          
          echo "Creating branch: $BRANCH_NAME" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Check if branch already exists locally or remotely
          if git show-ref --verify --quiet refs/heads/"$BRANCH_NAME"; then
            echo "âš ï¸ Branch $BRANCH_NAME already exists locally, switching to it" >> ${{ steps.validate-trigger.outputs.log_file }}
            git checkout "$BRANCH_NAME"
          elif git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Branch $BRANCH_NAME exists remotely, checking it out" >> ${{ steps.validate-trigger.outputs.log_file }}
            git checkout -b "$BRANCH_NAME" "origin/$BRANCH_NAME"
          else
            echo "âœ… Creating new branch: $BRANCH_NAME" >> ${{ steps.validate-trigger.outputs.log_file }}
          git checkout -b "$BRANCH_NAME"
          fi
          
          # Create audio directory in repository if it doesn't exist
          mkdir -p build/radio/assets/audios
          
          # Copy audio file to repository with new naming convention (no "issue" reference)
          LOCAL_FILENAME="${{ steps.download-audio.outputs.local_filename }}"
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          NEW_FILENAME="audio_${ISSUE_NUMBER}_${TIMESTAMP}.mp3"
          
          cp "generated_audio/$LOCAL_FILENAME" "build/radio/assets/audios/$NEW_FILENAME"
          
          echo "- Audio file renamed to: $NEW_FILENAME" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Create metadata file using jq for proper JSON formatting
          # Save multiline lyrics to a temporary file to handle newlines properly
          echo "${{ steps.extract-params.outputs.lyrics }}" > temp_lyrics.txt
          
          USED_SEED="${{ steps.generate-audio.outputs.used_seed }}"
          REQUESTED_SEED="${{ steps.extract-params.outputs.seed }}"
          
          if [ -n "$USED_SEED" ] && [ "$USED_SEED" != "" ] && [ "$USED_SEED" != "''" ]; then
            jq -n \
              --arg issue_number "$ISSUE_NUMBER" \
              --arg issue_title "${{ github.event.issue.title }}" \
              --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --arg prompt "${{ steps.extract-params.outputs.prompt }}" \
              --rawfile lyrics temp_lyrics.txt \
              --arg duration "${{ steps.extract-params.outputs.duration }}" \
              --arg mode "${{ steps.extract-params.outputs.mode }}" \
              --arg requested_seed "$REQUESTED_SEED" \
              --arg used_seed "$USED_SEED" \
              --arg generation_time "${{ steps.generate-audio.outputs.generation_time }}" \
              --arg file_size "${{ steps.download-audio.outputs.file_size }}" \
              --arg generated_by "${{ github.actor }}" \
              '{
                "issue_number": ($issue_number | tonumber),
                "issue_title": $issue_title,
                "generated_at": $generated_at,
            "parameters": {
                  "prompt": $prompt,
                  "lyrics": $lyrics,
                  "duration": ($duration | tonumber),
                  "mode": $mode,
                  "seed": {
                    "requested": ($requested_seed | if . == "" or . == null then null else tonumber end),
                    "used": ($used_seed | if . == "" or . == null then null else tonumber end)
                  }
                },
                "generation_time": $generation_time,
                "file_size": $file_size,
                "generated_by": $generated_by
              }' > "build/radio/assets/audios/${NEW_FILENAME%.mp3}_metadata.json"
          else
            jq -n \
              --arg issue_number "$ISSUE_NUMBER" \
              --arg issue_title "${{ github.event.issue.title }}" \
              --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --arg prompt "${{ steps.extract-params.outputs.prompt }}" \
              --rawfile lyrics temp_lyrics.txt \
              --arg duration "${{ steps.extract-params.outputs.duration }}" \
              --arg mode "${{ steps.extract-params.outputs.mode }}" \
              --arg requested_seed "$REQUESTED_SEED" \
              --arg generation_time "${{ steps.generate-audio.outputs.generation_time }}" \
              --arg file_size "${{ steps.download-audio.outputs.file_size }}" \
              --arg generated_by "${{ github.actor }}" \
              '{
                "issue_number": ($issue_number | tonumber),
                "issue_title": $issue_title,
                "generated_at": $generated_at,
                "parameters": {
                  "prompt": $prompt,
                  "lyrics": $lyrics,
                  "duration": ($duration | tonumber),
                  "mode": $mode,
                  "seed": {
                    "requested": ($requested_seed | if . == "" or . == null then null else tonumber end),
                    "used": null
                  }
                },
                "generation_time": $generation_time,
                "file_size": $file_size,
                "generated_by": $generated_by
              }' > "build/radio/assets/audios/${NEW_FILENAME%.mp3}_metadata.json"
          fi
          
          # Clean up temporary file
          rm -f temp_lyrics.txt
          
          # Update manifest file for radio interface
          # CONFLICT PREVENTION: We only update the tracks array to avoid merge conflicts
          # when multiple PRs are created simultaneously. The frontend calculates
          # total_tracks dynamically from tracks.length, and last_updated is not used.
          echo "ðŸ“ Updating audio manifest..." >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "ðŸš« Note: Not updating total_tracks/last_updated to prevent merge conflicts between concurrent PRs" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Create or update manifest.json
          MANIFEST_FILE="build/radio/assets/audios/manifest.json"
          
          # Load existing manifest or create new one
          if [ -f "$MANIFEST_FILE" ]; then
            cp "$MANIFEST_FILE" manifest_backup.json
          else
            # Create minimal manifest structure (total_tracks and last_updated are calculated dynamically by frontend)
            echo '{"tracks": [], "schedule_info": {"timezone": "UTC", "slot_duration": 30, "auto_advance": true, "live_mode_default": true}}' > "$MANIFEST_FILE"
          fi
          
          # Create new track entry using jq to properly escape JSON
          # Save multiline lyrics to a temporary file to handle newlines properly
          echo "${{ steps.extract-params.outputs.lyrics }}" > temp_lyrics_manifest.txt
          
          # Create new track entry using jq for proper JSON formatting
          if [ -n "$USED_SEED" ] && [ "$USED_SEED" != "" ] && [ "$USED_SEED" != "''" ]; then
            jq -n \
              --arg id "track_$ISSUE_NUMBER" \
              --arg title "${{ github.event.issue.title }}" \
              --arg artist "mentria.ai" \
              --arg file "assets/audios/$NEW_FILENAME" \
              --arg issue_number "$ISSUE_NUMBER" \
              --arg issue_title "${{ github.event.issue.title }}" \
              --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --arg prompt "${{ steps.extract-params.outputs.prompt }}" \
              --rawfile lyrics temp_lyrics_manifest.txt \
              --arg duration "${{ steps.extract-params.outputs.duration }}" \
              --arg mode "${{ steps.extract-params.outputs.mode }}" \
              --arg requested_seed "$REQUESTED_SEED" \
              --arg used_seed "$USED_SEED" \
              --arg generation_time "${{ steps.generate-audio.outputs.generation_time }}" \
              --arg file_size "${{ steps.download-audio.outputs.file_size }}" \
              --arg generated_by "${{ github.actor }}" \
              '{
                "id": $id,
                "title": $title,
                "artist": $artist,
                "file": $file,
                "metadata": {
                  "issue_number": ($issue_number | tonumber),
                  "issue_title": $issue_title,
                  "generated_at": $generated_at,
                  "parameters": {
                    "prompt": $prompt,
                    "lyrics": $lyrics,
                    "duration": ($duration | tonumber),
                    "mode": $mode,
                    "seed": {
                      "requested": ($requested_seed | if . == "" or . == null then null else tonumber end),
                      "used": ($used_seed | if . == "" or . == null then null else tonumber end)
                    }
                  },
                  "generation_time": $generation_time,
                  "file_size": $file_size,
                  "generated_by": $generated_by
                },
                "duration": ($duration | tonumber),
                "issueNumber": ($issue_number | tonumber)
              }' > new_track.json
          else
            jq -n \
              --arg id "track_$ISSUE_NUMBER" \
              --arg title "${{ github.event.issue.title }}" \
              --arg artist "mentria.ai" \
              --arg file "assets/audios/$NEW_FILENAME" \
              --arg issue_number "$ISSUE_NUMBER" \
              --arg issue_title "${{ github.event.issue.title }}" \
              --arg generated_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --arg prompt "${{ steps.extract-params.outputs.prompt }}" \
              --rawfile lyrics temp_lyrics_manifest.txt \
              --arg duration "${{ steps.extract-params.outputs.duration }}" \
              --arg mode "${{ steps.extract-params.outputs.mode }}" \
              --arg requested_seed "$REQUESTED_SEED" \
              --arg generation_time "${{ steps.generate-audio.outputs.generation_time }}" \
              --arg file_size "${{ steps.download-audio.outputs.file_size }}" \
              --arg generated_by "${{ github.actor }}" \
              '{
                "id": $id,
                "title": $title,
                "artist": $artist,
                "file": $file,
                "metadata": {
                  "issue_number": ($issue_number | tonumber),
                  "issue_title": $issue_title,
                  "generated_at": $generated_at,
                  "parameters": {
                    "prompt": $prompt,
                    "lyrics": $lyrics,
                    "duration": ($duration | tonumber),
                    "mode": $mode,
                                         "seed": {
                       "requested": ($requested_seed | if . == "" or . == null then null else tonumber end),
                       "used": null
                     }
                  },
                  "generation_time": $generation_time,
                  "file_size": $file_size,
                  "generated_by": $generated_by
                },
                "duration": ($duration | tonumber),
                "issueNumber": ($issue_number | tonumber)
              }' > new_track.json
          fi
          
          # Clean up temporary file
          rm -f temp_lyrics_manifest.txt
          
          # Check if this track already exists in manifest (avoid duplicates)
          TRACK_EXISTS=$(jq --arg id "track_$ISSUE_NUMBER" '.tracks[] | select(.id == $id)' "$MANIFEST_FILE")
          
          if [ -n "$TRACK_EXISTS" ]; then
            echo "âš ï¸ Track already exists in manifest, updating it" >> ${{ steps.validate-trigger.outputs.log_file }}
            # Remove existing track and add new one (without updating total_tracks or last_updated to prevent conflicts)
            jq --arg id "track_$ISSUE_NUMBER" \
               --argjson newtrack "$(cat new_track.json)" \
               '.tracks = (.tracks | map(select(.id != $id))) + [$newtrack]' \
               "$MANIFEST_FILE" > manifest_updated.json
          else
            echo "âœ… Adding new track to manifest" >> ${{ steps.validate-trigger.outputs.log_file }}
            # Add new track (without updating total_tracks or last_updated to prevent conflicts)
            jq --argjson newtrack "$(cat new_track.json)" \
               '.tracks += [$newtrack]' \
               "$MANIFEST_FILE" > manifest_updated.json
          fi
          
          mv manifest_updated.json "$MANIFEST_FILE"
          rm -f new_track.json manifest_backup.json
          
          echo "âœ… Manifest updated with track" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "ðŸ’¡ Note: Frontend calculates total_tracks dynamically from tracks.length" >> ${{ steps.validate-trigger.outputs.log_file }}
          
          # Add files to git
          git add "build/radio/assets/audios/$NEW_FILENAME"
          git add "build/radio/assets/audios/${NEW_FILENAME%.mp3}_metadata.json"
          git add "$MANIFEST_FILE"
          
          # Check if there are any changes to commit
          if git diff --staged --quiet; then
            echo "âš ï¸ No changes to commit (files may already exist)" >> ${{ steps.validate-trigger.outputs.log_file }}
          else
          # Commit changes
            SEED_INFO=""
            if [ -n "$USED_SEED" ] && [ "$USED_SEED" != "" ] && [ "$USED_SEED" != "''" ]; then
              if [ -n "$REQUESTED_SEED" ] && [ "$REQUESTED_SEED" != "" ]; then
                SEED_INFO="- Seed: $USED_SEED (as requested)"
              else
                SEED_INFO="- Seed: $USED_SEED (randomly generated)"
              fi
            elif [ -n "$REQUESTED_SEED" ] && [ "$REQUESTED_SEED" != "" ]; then
              SEED_INFO="- Seed: $REQUESTED_SEED (requested)"
            fi
            
            git commit -m "Add generated audio for #$ISSUE_NUMBER
          
          Generated audio with OctoBeats using the following parameters:
          - Prompt: ${{ steps.extract-params.outputs.prompt }}
          - Duration: ${{ steps.extract-params.outputs.duration }} seconds
          - Mode: ${{ steps.extract-params.outputs.mode }}
            $SEED_INFO
          - Generation time: ${{ steps.generate-audio.outputs.generation_time }}s
          
          Resolves #$ISSUE_NUMBER"
          
            echo "âœ… Changes committed" >> ${{ steps.validate-trigger.outputs.log_file }}
          fi
          
          # Push branch (force push in case of conflicts)
          git push origin "$BRANCH_NAME" || git push --force-with-lease origin "$BRANCH_NAME"
          
          echo "âœ… Branch pushed successfully" >> ${{ steps.validate-trigger.outputs.log_file }}
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "audio_filename=$NEW_FILENAME" >> $GITHUB_OUTPUT
      
      - name: Create pull request
        if: steps.create-branch.outputs.branch_name
        id: create-pr
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const logFile = '${{ steps.validate-trigger.outputs.log_file }}';
            
            fs.appendFileSync(logFile, `\n## Pull Request Creation\n`);
            
            const branchName = '${{ steps.create-branch.outputs.branch_name }}';
            const audioFilename = '${{ steps.create-branch.outputs.audio_filename }}';
            const issueNumber = context.payload.issue.number;
            const issueTitle = context.payload.issue.title;
            
            // Safely escape values for use in template strings
            const promptText = `${{ steps.extract-params.outputs.prompt }}`.replace(/[`"\\]/g, '\\$&');
            const lyricsText = `${{ steps.extract-params.outputs.lyrics }}`.replace(/[`"\\]/g, '\\$&');
            const modeText = `${{ steps.extract-params.outputs.mode }}`.replace(/[`"\\]/g, '\\$&');
            
            // Create PR body - safely handle potentially empty values
            const usedSeed = `${{ steps.generate-audio.outputs.used_seed }}` || '';
            const requestedSeed = `${{ steps.extract-params.outputs.seed }}` || '';
            const userPermission = `${{ steps.validate-trigger.outputs.user_permission }}` || '';
            const approvedBy = `${{ steps.validate-trigger.outputs.approved_by }}` || '';
            const approvalMethod = `${{ steps.validate-trigger.outputs.approval_method }}` || '';
            
            let seedSection = '';
            if (usedSeed && usedSeed !== '') {
              if (requestedSeed && requestedSeed !== '') {
                seedSection = `\n            - **Seed**: ${usedSeed} (as requested)`;
              } else {
                seedSection = `\n            - **Seed**: ${usedSeed} (randomly generated)`;
              }
            } else if (requestedSeed && requestedSeed !== '') {
              seedSection = `\n            - **Seed**: ${requestedSeed} (requested, but not confirmed from response)`;
            }
            
            let approvalSection = '';
            if (userPermission === 'approved_via_reaction' && approvedBy) {
              const reactionEmoji = approvalMethod.includes('owner') ? 'ðŸ‘‘' : 'ðŸ›¡ï¸';
              approvalSection = `\n            - **Approved By**: @${approvedBy} ${reactionEmoji} (via ${approvalMethod.replace('_', ' ')})`;
            }
            
            const prBody = `## ðŸŽµ Generated Audio for #${issueNumber}
            
            This PR adds the audio file generated using OctoBeats based on the parameters specified in #${issueNumber}.
            
            ### ðŸ“‹ Generation Details
            
            - **Request**: #${issueNumber} - ${issueTitle}
            - **Audio File**: \`build/radio/assets/audios/${audioFilename}\`
            - **Prompt**: "${promptText}"
            - **Lyrics**: "${lyricsText}"
            - **Duration**: ${{ steps.extract-params.outputs.duration }} seconds
            - **Quality Mode**: "${modeText}"${seedSection}
            - **Generation Time**: ${{ steps.generate-audio.outputs.generation_time }}s
            - **File Size**: ${{ steps.download-audio.outputs.file_size }}
            - **Generated By**: @${{ github.actor }}
            - **Generated At**: ${new Date().toISOString()}${approvalSection}
            
            ### ðŸ“ Files Added
            
            - \`build/radio/assets/audios/${audioFilename}\` - The generated audio file
            - \`build/radio/assets/audios/${audioFilename.replace('.mp3', '_metadata.json')}\` - Metadata about the generation
            
            ### ðŸŽ§ How to Listen
            
            1. Download the audio file from this PR
            2. Or check it out locally: \`git checkout ${branchName}\`
            3. The audio file is located at \`build/radio/assets/audios/${audioFilename}\`
            
            ---
            
            *This PR was automatically created by the OctoBeats Music Generator workflow.*
            
            Closes #${issueNumber}`;
            
            try {
              // Check if PR already exists for this branch
              let existingPR = null;
              try {
                const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                  head: `${context.repo.owner}:${branchName}`,
                  state: 'open'
                });
                
                if (prs.length > 0) {
                  existingPR = prs[0];
                  fs.appendFileSync(logFile, `âš ï¸ Found existing PR #${existingPR.number} for branch ${branchName}\n`);
                }
              } catch (error) {
                fs.appendFileSync(logFile, `â„¹ï¸ No existing PR found for branch ${branchName}\n`);
              }
              
              let pr;
              if (existingPR) {
                // Update existing PR
                pr = await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: existingPR.number,
                  title: `ðŸŽµ Add generated audio for #${issueNumber}`,
                  body: prBody
                });
                
                fs.appendFileSync(logFile, `âœ… Updated existing PR #${existingPR.number}\n`);
                pr = { data: existingPR };
              } else {
                // Create new PR
                pr = await github.rest.pulls.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: `ðŸŽµ Add generated audio for #${issueNumber}`,
                head: branchName,
                base: 'main',
                body: prBody,
                draft: false
              });
              
                fs.appendFileSync(logFile, `âœ… Created new PR #${pr.data.number}\n`);
              }
              
              fs.appendFileSync(logFile, `- PR #${pr.data.number}: ${pr.data.title}\n`);
              fs.appendFileSync(logFile, `- URL: ${pr.data.html_url}\n`);
              
              // Add labels to the PR
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.data.number,
                labels: ['audio', 'octobeats', 'auto-generated']
              });
              
              fs.appendFileSync(logFile, `- Labels added to PR\n`);
              
              core.setOutput('pr_number', pr.data.number);
              core.setOutput('pr_url', pr.data.html_url);
              
              return {
                pr_number: pr.data.number,
                pr_url: pr.data.html_url
              };
            } catch (error) {
              fs.appendFileSync(logFile, `âŒ Error creating/updating pull request: ${error.message}\n`);
              core.setFailed(`Error creating/updating pull request: ${error.message}`);
            }
      
      - name: Upload audio as artifact for preview
        if: steps.download-audio.outputs.download_success == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: generated-audio-track-${{ github.event.issue.number }}
          path: build/radio/assets/audios/${{ steps.create-branch.outputs.audio_filename }}
          retention-days: 30
      
      - name: Comment on original issue with audio preview
        if: steps.create-pr.outputs.pr_number
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const logFile = '${{ steps.validate-trigger.outputs.log_file }}';
            
            fs.appendFileSync(logFile, `\n## Issue Comment with Audio Preview\n`);
            
            const prNumber = '${{ steps.create-pr.outputs.pr_number }}';
            const prUrl = '${{ steps.create-pr.outputs.pr_url }}';
            const audioFilename = '${{ steps.create-branch.outputs.audio_filename }}';
            const issueNumber = context.payload.issue.number;
            const runId = context.runId;
            const usedSeed = `${{ steps.generate-audio.outputs.used_seed }}` || '';
            const requestedSeed = `${{ steps.extract-params.outputs.seed }}` || '';
            const userPermission = `${{ steps.validate-trigger.outputs.user_permission }}` || '';
            const approvedBy = `${{ steps.validate-trigger.outputs.approved_by }}` || '';
            const approvalMethod = `${{ steps.validate-trigger.outputs.approval_method }}` || '';
            
            // Safely escape values for use in template strings
            const promptText = `${{ steps.extract-params.outputs.prompt }}`.replace(/[`"\\]/g, '\\$&');
            const lyricsText = `${{ steps.extract-params.outputs.lyrics }}`.replace(/[`"\\]/g, '\\$&');
            const modeText = `${{ steps.extract-params.outputs.mode }}`.replace(/[`"\\]/g, '\\$&');
            
            // Create download URL for the artifact
            const artifactDownloadUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}`;
            
            // Create approval information if applicable
            let approvalInfo = '';
            if (userPermission === 'approved_via_reaction' && approvedBy) {
              const reactionEmoji = approvalMethod.includes('owner') ? 'ðŸ‘‘' : 'ðŸ›¡ï¸';
              approvalInfo = `\n- **Approved By**: @${approvedBy} ${reactionEmoji} (via ${approvalMethod.replace('_', ' ')})`;
            }
            
            const comment = `## ðŸŽµ Audio Generated Successfully!
            
            Your audio has been generated using OctoBeats and is ready for review!
            
            ### ðŸŽ§ **Preview Audio** (Click to Download & Play)
            
            **[â¬‡ï¸ Download Generated Audio: \`${audioFilename}\`](${artifactDownloadUrl})**
            
            > ðŸ’¡ **How to preview**: Click the link above â†’ Go to "Artifacts" section â†’ Download \`generated-audio-track-${issueNumber}\` â†’ Extract and play the MP3 file
            
            ### ðŸ“‹ Generation Summary
            
            - **Generated File**: \`${audioFilename}\`
            - **Prompt**: "${promptText}"
            - **Duration**: ${{ steps.extract-params.outputs.duration }} seconds
            - **Quality Mode**: "${modeText}"
            - **Seed**: ${usedSeed || 'Random generation'}${requestedSeed && requestedSeed !== usedSeed ? ` (requested: ${requestedSeed})` : ''}
            - **Generation Time**: ${{ steps.generate-audio.outputs.generation_time }}s
            - **File Size**: ${{ steps.download-audio.outputs.file_size }}${approvalInfo}
            
            ### ðŸŽ¼ Generated Parameters
            
            <details>
            <summary>ðŸ“ View Full Parameters</summary>
            
            \`\`\`json
            {
              "prompt": "${promptText}",
              "lyrics": "${lyricsText}",
              "duration": ${{ steps.extract-params.outputs.duration }},
              "mode": "${modeText}",
              "seed": {
                "requested": ${requestedSeed || 'null'},
                "used": ${usedSeed || 'null'}
              }
            }
            \`\`\`
            </details>
            
            ### ðŸ”— Next Steps
            
            1. **ðŸŽ§ Preview Audio**: Use the download link above to listen to your generated music
            2. **ðŸ“ Review PR**: [#${prNumber}](${prUrl}) - Check the technical details
            3. **âœ… Approve & Merge**: If you're satisfied with the audio, merge the PR to add it to your radio
            4. **ðŸŽµ Listen on Radio**: After merging, your track will appear in the [OctoBeats Radio](/radio/)
            
            ### ðŸ› ï¸ Alternative Download Methods
            
            <details>
            <summary>ðŸ”§ For Developers</summary>
            
            **Via Git:**
            \`\`\`bash
            git checkout ${{ steps.create-branch.outputs.branch_name }}
            # Audio file is at: build/radio/assets/audios/${audioFilename}
            \`\`\`
            
            **Via PR Files:**
            - Go to [PR #${prNumber}](${prUrl})
            - Click "Files changed" tab
            - Find \`build/radio/assets/audios/${audioFilename}\`
            - Click "View file" â†’ "Download"
            </details>
            
            ---
            
            ðŸ¤– *Generated automatically by OctoBeats Music Generator* | ðŸŽµ *Powered by Mentria.AI*`;
            
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                body: comment
              });
              
              fs.appendFileSync(logFile, `âœ… Comment with audio preview added to issue #${context.payload.issue.number}\n`);
              fs.appendFileSync(logFile, `- Artifact download URL: ${artifactDownloadUrl}\n`);
            } catch (error) {
              fs.appendFileSync(logFile, `âŒ Error commenting on issue: ${error.message}\n`);
              // Don't fail the workflow for comment errors
            }
      
      - name: Cleanup temporary files
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up temporary files..."
          rm -f audio_params.json generation_request.json generation_response.json server_status.json
          rm -rf generated_audio
          echo "âœ… Cleanup completed"
      
      - name: Upload workflow logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: octobeats-workflow-logs-${{ github.run_number }}
          path: |
            ${{ steps.validate-trigger.outputs.log_file }}
            *.json
          retention-days: 7 