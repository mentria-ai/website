name: Auto Music Generator

on:
  schedule:
    # Runs every 15 minutes
    - cron: '*/15 * * * *'
  workflow_dispatch:  # Allow manual triggering for testing
    inputs:
      custom_theme:
        description: 'Optional theme for music generation (e.g., "ambient", "electronic", "rock")'
        required: false
        default: ''

# Explicit permission scoping
permissions:
  contents: read
  issues: write
  actions: read

jobs:
  generate-music-request:
    runs-on: ubuntu-latest
    timeout-minutes: 10  # Should complete quickly
    
    steps:
      - name: Validate API key and setup
        id: validate-setup
        run: |
          echo "🔑 Validating Together API key..."
          if [[ -z "${{ secrets.TOGETHER_API_KEY }}" ]]; then
            echo "::error::Missing Together API key. Please add it to your repository secrets."
            exit 1
          fi
          
          # Create log file
          LOG_FILE="auto_music_generator_$(date +%Y%m%d_%H%M%S).log"
          echo "# Auto Music Generator Log - $(date -u +"%Y-%m-%dT%H:%M:%SZ")" > "$LOG_FILE"
          echo "## Workflow Started" >> "$LOG_FILE"
          echo "- Triggered by: ${{ github.event_name }}" >> "$LOG_FILE"
          echo "- Run ID: ${{ github.run_id }}" >> "$LOG_FILE"
          echo "- Repository: ${{ github.repository }}" >> "$LOG_FILE"
          echo "" >> "$LOG_FILE"
          
          echo "log_file=$LOG_FILE" >> $GITHUB_OUTPUT
          echo "✅ Setup validation completed"
      
      - name: Generate music parameters with AI
        id: generate-params
        run: |
          echo "🎵 Generating music parameters using DeepSeek-V3..."
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## AI Music Parameter Generation" >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Get custom theme if provided
          CUSTOM_THEME="${{ github.event.inputs.custom_theme }}"
          if [[ -n "$CUSTOM_THEME" ]]; then
            echo "🎨 Using custom theme: $CUSTOM_THEME" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          
          # Create the system prompt with current context
          CURRENT_TIME=$(date +"%H:%M")
          CURRENT_DATE=$(date +"%A, %B %d, %Y")
          
          cat > music_generation_prompt.txt << 'PROMPTEOF'
          You are an AI music production specialist with deep expertise in ACE-Step, a state-of-the-art diffusion-based text-to-music generation system. Your task is to generate creative, high-quality music parameters optimized for ACE-Step's advanced capabilities including superior lyric alignment, fast generation, and musical coherence across diverse genres.

          **ACE-Step Context & Capabilities:**
          - ACE-Step uses diffusion-based architecture for coherent, full-length music generation
          - Supports structured lyrics with section markers ([verse], [chorus], [bridge]) for optimal vocal alignment
          - Handles diverse genres with authentic instrumentation and style adaptation
          - Provides localized lyric editing while preserving melody and accompaniment
          - Achieves superior lyric-to-melody alignment compared to other models
          - Supports flexible duration control and maintains long-range structural coherence

          **Current Context:**
          - Current time: CURRENT_TIME_PLACEHOLDER
          - Current date: CURRENT_DATE_PLACEHOLDER
          - Target system: ACE-Step AI music generation
          - Output destination: Digital radio station content
          - Quality mode: Ultra (maximum fidelity)

          **Generation Guidelines:**

          **1. Style Prompt (ACE-Step Tags):**
          Create 4-8 descriptive tags in ACE-Step's format: comma-separated, lowercase descriptors covering:
          - **Genre**: pop, rock, jazz, electronic, classical, hip-hop, folk, ambient, etc.
          - **Mood/Energy**: upbeat, mellow, energetic, chill, dramatic, nostalgic, dreamy
          - **Era/Style**: 1980s, retro, modern, futuristic, vintage, contemporary  
          - **Instruments**: piano, guitar, synthesizer, orchestral, acoustic, electric
          - **Production**: reverb-heavy, lo-fi, crisp, analog, digital, atmospheric
          - **Vocals**: male vocal, female vocal, harmonies (if applicable)

          Examples: "electronic, ambient, ethereal, 85 bpm, reverb-heavy, synthesizer"
          Examples: "jazzy hip-hop, vinyl crackle, saxophone, laid-back, nostalgic"

          **2. Lyrics (ACE-Step Structure):**
          Generate structured lyrics optimized for ACE-Step's vocal alignment:

          **For Instrumental Tracks:** Use "[inst]" or creative structure tags like "[intro][build][drop][outro]"

          **For Vocal Tracks:** Create original lyrics with proper section structure:
          - Use section markers: [verse], [chorus], [bridge], [outro], [intro]
          - Ensure sections flow logically and tell a coherent story/theme
          - Match lyrical tone, themes, and language to the genre authentically
          - Use poetic devices (rhymes, rhythm, metaphors) appropriate to the style
          - Keep lines singable with natural rhythm and balanced syllable counts
          - Maintain consistent perspective and tense throughout
          - Avoid copying existing songs - create original, creative content

          **Genre-Style Alignment Examples:**
          - **Jazz**: Smooth, soulful, sophisticated language with emotional depth
          - **Pop**: Catchy, accessible, relatable themes with strong hooks  
          - **Folk**: Storytelling narrative with simple, heartfelt language
          - **Electronic**: Modern themes, possibly abstract or futuristic imagery
          - **Blues**: Emotionally heavy, personal struggles, authentic expression
          - **Hip-hop**: Rhythmic flow, contemporary references, cultural authenticity

          **3. Duration Selection:**
          Choose duration based on lyrical scope and genre conventions:
          - **30-60s**: Intros, transitions, ambient pieces, short-form content
          - **90-120s**: Complete songs with standard verse/chorus structure
          - **150-180s**: Extended compositions with multiple verses, bridge sections
          - **240s**: Complex arrangements, progressive structures, full narrative arcs

          **4. Title Creation:**
          Generate creative, genre-appropriate titles that:
          - Reflect the song's theme and mood
          - Sound authentic to the musical style
          - Are memorable and radio-friendly
          - Avoid clichés unless they serve the genre authentically

          **5. Creative Inspiration:**
          Provide brief insight into your creative process, mentioning:
          - Genre influences or fusion elements
          - Thematic inspiration (time of day, season, emotion, story)
          - Unique musical or lyrical approaches
          - Cultural or regional influences incorporated

          **Output Format (JSON only):**
          ```json
          {
            "style_prompt": "comma-separated, lowercase ACE-Step tags",
            "lyrics": "structured lyrics with [section] markers OR [inst] for instrumental",
            "duration": number (30, 45, 60, 90, 120, 150, 180, or 240),
            "title_suggestion": "creative, genre-appropriate title",
            "inspiration": "brief explanation of creative choices and influences"
          }
          ```

          **Quality Standards:**
          - **Authenticity**: Lyrics and tags must feel genuine to the specified genre
          - **Coherence**: Story/theme should flow logically from start to finish  
          - **Originality**: All content must be original, avoiding copyright infringement
          - **Cultural Sensitivity**: Respectful representation of musical traditions
          - **Appropriateness**: Suitable for radio broadcast, avoiding offensive content
          - **ACE-Step Optimization**: Structure designed for optimal vocal-melody alignment

          **Diversity Goals:**
          - Explore different musical cultures and regional influences
          - Mix traditional and experimental genre combinations  
          - Consider time-appropriate themes (morning energy, evening chill, etc.)
          - Balance instrumental and vocal compositions
          - Vary emotional ranges and energy levels
          - Incorporate seasonal and temporal context

          **Examples of ACE-Step Optimized Outputs:**

          **Ambient Electronic:**
          - Tags: "ambient, electronic, atmospheric, downtempo, synthesizer, ethereal"
          - Structure: Often instrumental ([inst]) or minimal vocals with [intro][ambient][outro]

          **Singer-Songwriter Folk:**
          - Tags: "folk, acoustic, storytelling, intimate, guitar, contemplative"  
          - Structure: [verse][chorus][verse][chorus][bridge][chorus] with narrative lyrics

          **Synthwave Retro:**
          - Tags: "synthwave, retro, 1980s, electronic, nostalgic, analog"
          - Structure: [intro][verse][chorus][verse][chorus][bridge][outro] with period-appropriate themes

          Generate something musically compelling and ACE-Step optimized now:
          PROMPTEOF
          
          # Replace placeholders with actual values
          sed -i "s/CURRENT_TIME_PLACEHOLDER/$CURRENT_TIME/g" music_generation_prompt.txt
          sed -i "s/CURRENT_DATE_PLACEHOLDER/$CURRENT_DATE/g" music_generation_prompt.txt
          
          # Add custom theme to prompt if provided
          if [[ -n "$CUSTOM_THEME" ]]; then
            echo "" >> music_generation_prompt.txt
            echo "**Special Theme Request:** Focus on or incorporate elements of: $CUSTOM_THEME" >> music_generation_prompt.txt
          fi
          
          # Create API request payload using Python to avoid jq parsing issues
          # Build Python script using echo to avoid YAML parsing conflicts
          echo "import json" > create_json.py
          echo "" >> create_json.py
          echo "with open('music_generation_prompt.txt', 'r') as f:" >> create_json.py
          echo "    prompt_content = f.read()" >> create_json.py
          echo "" >> create_json.py
          echo "payload = {" >> create_json.py
          echo "    'model': 'deepseek-ai/DeepSeek-V3'," >> create_json.py
          echo "    'messages': [{'role': 'user', 'content': prompt_content}]," >> create_json.py
          echo "    'max_tokens': 1000," >> create_json.py
          echo "    'temperature': 0.8" >> create_json.py
          echo "}" >> create_json.py
          echo "" >> create_json.py
          echo "with open('api_request.json', 'w') as f:" >> create_json.py
          echo "    json.dump(payload, f)" >> create_json.py
          
          # Execute the Python script
          python3 create_json.py
          
          echo "📡 Making API call to Together AI..." >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Make API call with detailed error handling
          HTTP_STATUS=$(curl -s -w "%{http_code}" -X POST "https://api.together.xyz/v1/chat/completions" \
            -H "Authorization: Bearer ${{ secrets.TOGETHER_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d @api_request.json \
            -o api_response.json)
          
          echo "📊 HTTP Status Code: $HTTP_STATUS" >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Check if API call was successful
          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✅ API call completed successfully" >> ${{ steps.validate-setup.outputs.log_file }}
            
            # Check if response file exists and has content
            if [[ -f "api_response.json" && -s "api_response.json" ]]; then
              echo "📁 Response file exists and has content" >> ${{ steps.validate-setup.outputs.log_file }}
              
              # Log first 200 characters of response for debugging
              echo "🔍 Response preview: $(head -c 200 api_response.json)" >> ${{ steps.validate-setup.outputs.log_file }}
              
              # Validate JSON format before parsing
              if python3 -c "import json; json.load(open('api_response.json'))" 2>/dev/null; then
                echo "✅ Response is valid JSON" >> ${{ steps.validate-setup.outputs.log_file }}
                
                # Extract content from response using Python for better error handling
                echo "import json" > extract_response.py
                echo "import sys" >> extract_response.py
                echo "" >> extract_response.py
                echo "try:" >> extract_response.py
                echo "    with open('api_response.json', 'r') as f:" >> extract_response.py
                echo "        response = json.load(f)" >> extract_response.py
                echo "" >> extract_response.py
                echo "    # Extract the content" >> extract_response.py
                echo "    content = response.get('choices', [{}])[0].get('message', {}).get('content', '')" >> extract_response.py
                echo "" >> extract_response.py
                echo "    if content:" >> extract_response.py
                echo "        print(f'SUCCESS:{content}')" >> extract_response.py
                echo "    else:" >> extract_response.py
                echo "        print('ERROR:No content found in response')" >> extract_response.py
                echo "" >> extract_response.py
                echo "except Exception as e:" >> extract_response.py
                echo "    print(f'ERROR:Failed to parse response: {e}')" >> extract_response.py
                
                EXTRACTION_RESULT=$(python3 extract_response.py)
                
                if [[ "$EXTRACTION_RESULT" == SUCCESS:* ]]; then
                  RESPONSE_CONTENT="${EXTRACTION_RESULT#SUCCESS:}"
                  echo "🎼 AI Response received (${#RESPONSE_CONTENT} characters)" >> ${{ steps.validate-setup.outputs.log_file }}
                  
                  # Extract JSON from response using Python
                  # Create a simple Python script to extract JSON
                  echo "import sys, json" > extract_json.py
                  echo "try:" >> extract_json.py
                  echo "    with open('response_content.txt', 'r') as f:" >> extract_json.py
                  echo "        content = f.read()" >> extract_json.py
                  echo "    # Find first { and last }" >> extract_json.py
                  echo "    start = content.find('{')" >> extract_json.py
                  echo "    end = content.rfind('}') + 1" >> extract_json.py
                  echo "    if start != -1 and end > start:" >> extract_json.py
                  echo "        json_text = content[start:end]" >> extract_json.py
                  echo "        try:" >> extract_json.py
                  echo "            data = json.loads(json_text)" >> extract_json.py
                  echo "            with open('extracted_json.txt', 'w') as f:" >> extract_json.py
                  echo "                json.dump(data, f)" >> extract_json.py
                  echo "            print('SUCCESS')" >> extract_json.py
                  echo "            sys.exit(0)" >> extract_json.py
                  echo "        except: pass" >> extract_json.py
                  echo "    # Fallback" >> extract_json.py
                  echo "    fallback = {'style_prompt': 'electronic, ambient, melodic', 'lyrics': '[inst]', 'duration': 90, 'title_suggestion': 'AI Generated Track', 'inspiration': 'Auto-generated'}" >> extract_json.py
                  echo "    with open('extracted_json.txt', 'w') as f:" >> extract_json.py
                  echo "        json.dump(fallback, f)" >> extract_json.py
                  echo "    print('FALLBACK')" >> extract_json.py
                  echo "except Exception as e:" >> extract_json.py
                  echo "    print('ERROR')" >> extract_json.py
                  
                  # Save response content to file (safer than shell variables)
                  printf '%s' "$RESPONSE_CONTENT" > response_content.txt
                  
                  python3 extract_json.py
                  
                  # Validate and extract parameters using Python
                  echo "import json" > extract_params.py
                  echo "import sys" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "try:" >> extract_params.py
                  echo "    with open('extracted_json.txt', 'r') as f:" >> extract_params.py
                  echo "        content = f.read().strip()" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    try:" >> extract_params.py
                  echo "        data = json.loads(content)" >> extract_params.py
                  echo "    except:" >> extract_params.py
                  echo "        # If not valid JSON, create fallback" >> extract_params.py
                  echo "        data = {}" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Extract parameters with fallbacks" >> extract_params.py
                  echo "    style_prompt = data.get('style_prompt', 'electronic, ambient, melodic')" >> extract_params.py
                  echo "    lyrics = data.get('lyrics', '[inst]')" >> extract_params.py
                  echo "    duration = data.get('duration', 90)" >> extract_params.py
                  echo "    title_suggestion = data.get('title_suggestion', 'AI Generated Track')" >> extract_params.py
                  echo "    inspiration = data.get('inspiration', 'Automatically generated music')" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Validate duration" >> extract_params.py
                  echo "    valid_durations = [30, 45, 60, 90, 120, 150, 180, 240]" >> extract_params.py
                  echo "    if duration not in valid_durations:" >> extract_params.py
                  echo "        duration = 90" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    # Clean parameters" >> extract_params.py
                  echo "    style_prompt = str(style_prompt).replace('\"', '').replace(\"'\", '')[:200]" >> extract_params.py
                  echo "    lyrics = str(lyrics).replace('\"', '').replace(\"'\", '')[:400]" >> extract_params.py
                  echo "    title_suggestion = str(title_suggestion).replace('\"', '').replace(\"'\", '')[:80]" >> extract_params.py
                  echo "    inspiration = str(inspiration).replace('\"', '').replace(\"'\", '')[:200]" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "    print(f'STYLE_PROMPT={style_prompt}')" >> extract_params.py
                  echo "    print(f'LYRICS={lyrics}')" >> extract_params.py
                  echo "    print(f'DURATION={duration}')" >> extract_params.py
                  echo "    print(f'TITLE_SUGGESTION={title_suggestion}')" >> extract_params.py
                  echo "    print(f'INSPIRATION={inspiration}')" >> extract_params.py
                  echo "    print('SUCCESS=true')" >> extract_params.py
                  echo "" >> extract_params.py
                  echo "except Exception as e:" >> extract_params.py
                  echo "    print(f'ERROR: {e}')" >> extract_params.py
                  echo "    print('SUCCESS=false')" >> extract_params.py
                  
                  # Extract parameters
                  PARAM_RESULT=$(python3 extract_params.py)
                  
                  if echo "$PARAM_RESULT" | grep -q "SUCCESS=true"; then
                    # Extract each parameter
                    STYLE_PROMPT=$(echo "$PARAM_RESULT" | grep "STYLE_PROMPT=" | cut -d'=' -f2-)
                    LYRICS=$(echo "$PARAM_RESULT" | grep "LYRICS=" | cut -d'=' -f2-)
                    DURATION=$(echo "$PARAM_RESULT" | grep "DURATION=" | cut -d'=' -f2-)
                    TITLE_SUGGESTION=$(echo "$PARAM_RESULT" | grep "TITLE_SUGGESTION=" | cut -d'=' -f2-)
                    INSPIRATION=$(echo "$PARAM_RESULT" | grep "INSPIRATION=" | cut -d'=' -f2-)
                    
                    # Encode parameters to prevent JavaScript syntax errors
                    STYLE_PROMPT_ENCODED=$(echo "$STYLE_PROMPT" | base64 -w 0)
                    LYRICS_ENCODED=$(echo "$LYRICS" | base64 -w 0)
                    TITLE_SUGGESTION_ENCODED=$(echo "$TITLE_SUGGESTION" | base64 -w 0)
                    INSPIRATION_ENCODED=$(echo "$INSPIRATION" | base64 -w 0)
                    
                    echo "🎵 Generated Parameters:" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Style: $STYLE_PROMPT" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Lyrics: ${LYRICS:0:100}..." >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Duration: $DURATION seconds" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Title: $TITLE_SUGGESTION" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "- Inspiration: $INSPIRATION" >> ${{ steps.validate-setup.outputs.log_file }}
                    
                    # Set outputs for next step (using encoded versions for JavaScript safety)
                    echo "style_prompt_encoded=$STYLE_PROMPT_ENCODED" >> $GITHUB_OUTPUT
                    echo "lyrics_encoded=$LYRICS_ENCODED" >> $GITHUB_OUTPUT
                    echo "duration=$DURATION" >> $GITHUB_OUTPUT
                    echo "title_suggestion_encoded=$TITLE_SUGGESTION_ENCODED" >> $GITHUB_OUTPUT
                    echo "inspiration_encoded=$INSPIRATION_ENCODED" >> $GITHUB_OUTPUT
                    echo "generation_success=true" >> $GITHUB_OUTPUT
                  else
                    echo "❌ Failed to extract parameters from AI response" >> ${{ steps.validate-setup.outputs.log_file }}
                    echo "generation_success=false" >> $GITHUB_OUTPUT
                  fi
                else
                  echo "❌ Failed to extract content from API response" >> ${{ steps.validate-setup.outputs.log_file }}
                  echo "generation_success=false" >> $GITHUB_OUTPUT
                fi
              else
                echo "❌ API response is not valid JSON" >> ${{ steps.validate-setup.outputs.log_file }}
                echo "📄 Raw response content:" >> ${{ steps.validate-setup.outputs.log_file }}
                cat api_response.json >> ${{ steps.validate-setup.outputs.log_file }}
                echo "generation_success=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "❌ API response file is missing or empty" >> ${{ steps.validate-setup.outputs.log_file }}
              echo "generation_success=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ API call failed with HTTP status: $HTTP_STATUS" >> ${{ steps.validate-setup.outputs.log_file }}
            if [[ -f "api_response.json" ]]; then
              echo "📄 Error response content:" >> ${{ steps.validate-setup.outputs.log_file }}
              cat api_response.json >> ${{ steps.validate-setup.outputs.log_file }}
            fi
            echo "generation_success=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Create music generation issue
        if: steps.generate-params.outputs.generation_success == 'true'
        id: create-issue
        env:
          STYLE_PROMPT_B64: ${{ steps.generate-params.outputs.style_prompt_encoded }}
          LYRICS_B64: ${{ steps.generate-params.outputs.lyrics_encoded }}
          DURATION: ${{ steps.generate-params.outputs.duration }}
          TITLE_B64: ${{ steps.generate-params.outputs.title_suggestion_encoded }}
          INSPIRATION_B64: ${{ steps.generate-params.outputs.inspiration_encoded }}
          CUSTOM_THEME: ${{ github.event.inputs.custom_theme }}
          LOG_FILE: ${{ steps.validate-setup.outputs.log_file }}
        run: |
          # Create JavaScript file to avoid YAML parsing issues
          cat > create_issue.js << 'JSEOF'
          const fs = require('fs');
          const { Octokit } = require('@octokit/rest');
          
          async function createIssue() {
            const logFile = process.env.LOG_FILE;
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            try {
              fs.appendFileSync(logFile, '\n## Creating GitHub Issue\n');
              
              // Decode parameters
              const stylePrompt = process.env.STYLE_PROMPT_B64 ? Buffer.from(process.env.STYLE_PROMPT_B64, 'base64').toString('utf8') : 'electronic, ambient, melodic';
              const lyrics = process.env.LYRICS_B64 ? Buffer.from(process.env.LYRICS_B64, 'base64').toString('utf8') : '[inst]';
              const duration = process.env.DURATION || '90';
              const titleSuggestion = process.env.TITLE_B64 ? Buffer.from(process.env.TITLE_B64, 'base64').toString('utf8') : 'AI Generated Track';
              const inspiration = process.env.INSPIRATION_B64 ? Buffer.from(process.env.INSPIRATION_B64, 'base64').toString('utf8') : 'Auto-generated';
              const customTheme = process.env.CUSTOM_THEME || 'None';
              
              const timestamp = new Date().toISOString().slice(0, 16).replace('T', ' ');
              const issueTitle = `[MUSIC] ${titleSuggestion} - Auto Generated ${timestamp}`;
              
              const issueBody = [
                '## 🎵 Auto-Generated Music Request',
                '',
                'This music generation request was automatically created by the Auto Music Generator workflow.',
                '',
                '### 🎼 Music Style Prompt',
                stylePrompt,
                '',
                '### 🎤 Lyrics or Structure',
                lyrics,
                '',
                '### ⏱️ Duration (seconds)',
                duration,
                '',
                '### 🎚️ Quality Mode',
                'ultra',
                '',
                '### 📝 Additional Notes',
                `**AI Inspiration:** ${inspiration}`,
                '',
                `**Generated at:** ${timestamp}`,
                `**Custom theme:** ${customTheme}`,
                '',
                '---',
                '',
                '### ✅ Confirmation',
                '- [x] I have the necessary permissions (owner/admin/maintainer) to request audio generation',
                '- [x] I understand that the OctoBeats server must be running for this to work',
                '- [x] I understand that this will create a new branch and pull request with the generated audio',
                '- [x] The parameters I've provided are appropriate and follow community guidelines',
                '',
                '---',
                '',
                '*This issue was automatically generated by the Auto Music Generator workflow. The parameters were created using DeepSeek-V3 AI model to ensure creative diversity and musical interest.*'
              ].join('\n');
              
              const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
              
              const issue = await octokit.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['audio', 'octobeats', 'auto-generated']
              });
              
              fs.appendFileSync(logFile, `✅ Created issue #${issue.data.number}: "${issue.data.title}"\n`);
              fs.appendFileSync(logFile, `🔗 Issue URL: ${issue.data.html_url}\n`);
              
              console.log(`::set-output name=issue_number::${issue.data.number}`);
              console.log(`::set-output name=issue_url::${issue.data.html_url}`);
              console.log(`::set-output name=issue_title::${issue.data.title}`);
              
            } catch (error) {
              fs.appendFileSync(logFile, `❌ Error creating issue: ${error.message}\n`);
              console.log(`::error::Error creating issue: ${error.message}`);
              process.exit(1);
            }
          }
          
          createIssue();
          JSEOF
          
          # Install required packages and run
          npm init -y > /dev/null 2>&1
          npm install @octokit/rest > /dev/null 2>&1
          GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}" node create_issue.js
      
      - name: Handle generation failure
        if: steps.generate-params.outputs.generation_success != 'true'
        run: |
          echo "❌ Music parameter generation failed" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## Fallback Parameters" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "Using fallback parameters to create a basic music request..." >> ${{ steps.validate-setup.outputs.log_file }}
          
          # Set fallback parameters
          FALLBACK_STYLES=("electronic, ambient, chill" "acoustic, folk, peaceful" "jazz, smooth, relaxing" "classical, orchestral, elegant" "synthwave, retro, nostalgic")
          FALLBACK_DURATIONS=(60 90 120)
          
          # Select random fallback values
          RANDOM_STYLE=${FALLBACK_STYLES[$RANDOM % ${#FALLBACK_STYLES[@]}]}
          RANDOM_DURATION=${FALLBACK_DURATIONS[$RANDOM % ${#FALLBACK_DURATIONS[@]}]}
          FALLBACK_TITLE="Auto Generated Track $(date +%H%M)"
          FALLBACK_INSPIRATION="Generated using fallback parameters after AI generation failed"
          
          # Encode fallback parameters for JavaScript safety
          FALLBACK_STYLE_ENCODED=$(echo "$RANDOM_STYLE" | base64 -w 0)
          FALLBACK_LYRICS_ENCODED=$(echo "[inst]" | base64 -w 0)
          FALLBACK_TITLE_ENCODED=$(echo "$FALLBACK_TITLE" | base64 -w 0)
          FALLBACK_INSPIRATION_ENCODED=$(echo "$FALLBACK_INSPIRATION" | base64 -w 0)
          
          echo "fallback_style_encoded=$FALLBACK_STYLE_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_lyrics_encoded=$FALLBACK_LYRICS_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_duration=$RANDOM_DURATION" >> $GITHUB_OUTPUT
          echo "fallback_title_encoded=$FALLBACK_TITLE_ENCODED" >> $GITHUB_OUTPUT
          echo "fallback_inspiration_encoded=$FALLBACK_INSPIRATION_ENCODED" >> $GITHUB_OUTPUT
      
      - name: Create fallback issue
        if: steps.generate-params.outputs.generation_success != 'true'
        env:
          FALLBACK_STYLE_B64: ${{ steps.handle-generation-failure.outputs.fallback_style_encoded }}
          FALLBACK_LYRICS_B64: ${{ steps.handle-generation-failure.outputs.fallback_lyrics_encoded }}
          FALLBACK_DURATION: ${{ steps.handle-generation-failure.outputs.fallback_duration }}
          FALLBACK_TITLE_B64: ${{ steps.handle-generation-failure.outputs.fallback_title_encoded }}
          FALLBACK_INSPIRATION_B64: ${{ steps.handle-generation-failure.outputs.fallback_inspiration_encoded }}
          LOG_FILE: ${{ steps.validate-setup.outputs.log_file }}
        run: |
          # Create JavaScript file for fallback issue
          cat > create_fallback_issue.js << 'JSEOF'
          const fs = require('fs');
          const { Octokit } = require('@octokit/rest');
          
          async function createFallbackIssue() {
            const logFile = process.env.LOG_FILE;
            const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
            
            try {
              fs.appendFileSync(logFile, '\n## Creating Fallback Issue\n');
              
              // Decode fallback parameters
              const fallbackStyle = process.env.FALLBACK_STYLE_B64 ? Buffer.from(process.env.FALLBACK_STYLE_B64, 'base64').toString('utf8') : 'electronic, ambient, melodic';
              const fallbackLyrics = process.env.FALLBACK_LYRICS_B64 ? Buffer.from(process.env.FALLBACK_LYRICS_B64, 'base64').toString('utf8') : '[inst]';
              const fallbackDuration = process.env.FALLBACK_DURATION || '90';
              const fallbackTitle = process.env.FALLBACK_TITLE_B64 ? Buffer.from(process.env.FALLBACK_TITLE_B64, 'base64').toString('utf8') : 'AI Generated Track';
              const fallbackInspiration = process.env.FALLBACK_INSPIRATION_B64 ? Buffer.from(process.env.FALLBACK_INSPIRATION_B64, 'base64').toString('utf8') : 'Fallback parameters';
              
              const timestamp = new Date().toISOString().slice(0, 16).replace('T', ' ');
              const issueTitle = `[MUSIC] ${fallbackTitle} - Auto Generated ${timestamp}`;
              
              const issueBody = [
                '## 🎵 Auto-Generated Music Request (Fallback)',
                '',
                'This music generation request was automatically created using fallback parameters due to AI generation failure.',
                '',
                '### 🎼 Music Style Prompt',
                fallbackStyle,
                '',
                '### 🎤 Lyrics or Structure',
                fallbackLyrics,
                '',
                '### ⏱️ Duration (seconds)',
                fallbackDuration,
                '',
                '### 🎚️ Quality Mode',
                'ultra',
                '',
                '### 📝 Additional Notes',
                `**AI Inspiration:** ${fallbackInspiration}`,
                '',
                `**Generated at:** ${timestamp}`,
                '',
                '---',
                '',
                '### ✅ Confirmation',
                '- [x] I have the necessary permissions (owner/admin/maintainer) to request audio generation',
                '- [x] I understand that the OctoBeats server must be running for this to work',
                '- [x] I understand that this will create a new branch and pull request with the generated audio',
                '- [x] The parameters I've provided are appropriate and follow community guidelines',
                '',
                '---',
                '',
                '*This issue was automatically generated using fallback parameters after AI generation failed.*'
              ].join('\n');
              
              const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
              
              const issue = await octokit.rest.issues.create({
                owner: owner,
                repo: repo,
                title: issueTitle,
                body: issueBody,
                labels: ['audio', 'octobeats', 'auto-generated', 'fallback']
              });
              
              fs.appendFileSync(logFile, `✅ Created fallback issue #${issue.data.number}\n`);
              fs.appendFileSync(logFile, `🔗 Issue URL: ${issue.data.html_url}\n`);
              
            } catch (error) {
              fs.appendFileSync(logFile, `❌ Error creating fallback issue: ${error.message}\n`);
              console.log(`::error::Error creating fallback issue: ${error.message}`);
            }
          }
          
          createFallbackIssue();
          JSEOF
          
          # Install required packages and run (if not already installed)
          if [ ! -d "node_modules" ]; then
            npm init -y > /dev/null 2>&1
            npm install @octokit/rest > /dev/null 2>&1
          fi
          GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}" node create_fallback_issue.js
      
      - name: Cleanup and finalize
        if: always()
        run: |
          echo "" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "## Workflow Completion" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "- Completed at: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> ${{ steps.validate-setup.outputs.log_file }}
          echo "- Status: ${{ job.status }}" >> ${{ steps.validate-setup.outputs.log_file }}
          
          if [[ "${{ steps.create-issue.outputs.issue_number }}" != "" ]]; then
            echo "- Created issue: #${{ steps.create-issue.outputs.issue_number }}" >> ${{ steps.validate-setup.outputs.log_file }}
            echo "🎵 Successfully created auto-generated music request!"
          else
            echo "- No issue created (workflow failed or used fallback)" >> ${{ steps.validate-setup.outputs.log_file }}
          fi
          
          # Clean up temporary files
          rm -f music_generation_prompt.txt api_request.json api_response.json extracted_json.txt create_json.py extract_response.py extract_json.py extract_params.py response_content.txt create_issue.js create_fallback_issue.js package.json package-lock.json
          rm -rf node_modules
          
          echo "✅ Auto Music Generator workflow completed"
      
      - name: Upload workflow logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: auto-music-generator-logs-${{ github.run_number }}
          path: |
            ${{ steps.validate-setup.outputs.log_file }}
            *.json
            *.txt
          retention-days: 7